<HTML>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<!-- Created on January, 9  2008 by texi2html 1.64 -->
<!-- 
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Olaf Bachmann <obachman@mathematik.uni-kl.de>
Send bugs and suggestions to <texi2html@mathematik.uni-kl.de>
 
-->
<HEAD>
<TITLE>Preliminary Design of JML: Footnotes</TITLE>

<META NAME="description" CONTENT="Preliminary Design of JML: Footnotes">
<META NAME="keywords" CONTENT="Preliminary Design of JML: Footnotes">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<META NAME="Generator" CONTENT="texi2html 1.64">

</HEAD>

<BODY LANG="" BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#0000FF" VLINK="#800080" ALINK="#FF0000">

<A NAME="prelimdesign_fot.html"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="prelimdesign.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="prelimdesign_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="prelimdesign_7.html#SEC56">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="prelimdesign_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H1>Footnotes</H1>
<H3><A NAME="FOOT1" HREF="prelimdesign_1.html#DOCF1">(1)</A></H3>
<P>
In JML method specifications must be placed either before the method's
header, as shown above, or between the method's header and its body.
In this document, we always place the specification before the method header.
This convention is followed by many Java tools, in particular by Javadoc;
It has the advantage of working in all cases, even when the method has no body.

<H3><A NAME="FOOT2" HREF="prelimdesign_1.html#DOCF2">(2)</A></H3>
<P>
In a protected specification,
both public and protected identifiers can be used.
In a specification with default (i.e., no) visibility specified,
which corresponds to Java's default visibility,
public and protected identifiers can be used, as well as identifiers
from the same package with default visibility.
A private specification can use any identifiers that are available.
The privacy level of a method specification
cannot allow more access than the method being specified.
Thus a public method may have a private specification,
but a private method may not have a public specification.

<H3><A NAME="FOOT3" HREF="prelimdesign_1.html#DOCF3">(3)</A></H3>
<P>
The keyword <CODE>pre</CODE> can also be used as a synonym for <CODE>requires</CODE>.
<H3><A NAME="FOOT4" HREF="prelimdesign_1.html#DOCF4">(4)</A></H3>
<P>
The keyword <CODE>post</CODE> can also be used as a synonym for <CODE>ensures</CODE>.
<H3><A NAME="FOOT5" HREF="prelimdesign_1.html#DOCF5">(5)</A></H3>
<P>
The result plus one squared will become negative if the result is
larger than 46340, due to integer overflow.
Patrice Chalin pointed out that in an earlier version of this
specification there were overflow problems <A HREF="prelimdesign_6.html#BIB18">[Chalin02]</A>.
In Java integer arithmetic, one plus the maximum integer is the
minimum integer. 
This specification deals with such problems by limiting the result to
be a positive integer and by the implication on lines 8-9.
See the specification of <CODE>IntMathOps2</CODE> below for another way to deal with
these problems.

<H3><A NAME="FOOT6" HREF="prelimdesign_1.html#DOCF6">(6)</A></H3>
<P>
Since HTML tags are not case sensitive, in this one place JML
is also not case sensitive.
That is, the syntax also permits the tags <CODE>&#60;JML&#62;</CODE>, <CODE>&#60;/JML&#62;</CODE>.
For compatibility with ESC/Java, JML also supports the tags
<CODE>&#60;esc&#62;</CODE>, <CODE>&#60;/esc&#62;</CODE>, <CODE>&#60;ESC&#62;</CODE>, and <CODE>&#60;/ESC&#62;</CODE>.
<H3><A NAME="FOOT7" HREF="prelimdesign_1.html#DOCF7">(7)</A></H3>
<P>
<A NAME="IDX77"></A>
Because the current ESC/Java2 tool does not
understand <CODE>spec_bigint_math</CODE> mode,
the specification uses uses annotation markers
<CODE>/*+@</CODE> and <CODE>@+*/</CODE>.
These markers are understood by the ISU JML tools, but are considered to
be comments by ESC/Java2.

<H3><A NAME="FOOT8" HREF="prelimdesign_1.html#DOCF8">(8)</A></H3>
<P> 
The <CODE>jmldoc</CODE> tool is generously provided by David Cok; thanks David!.
<H3><A NAME="FOOT9" HREF="prelimdesign_2.html#DOCF9">(9)</A></H3>
<P>
In JML invariants also apply to non-public methods as well.  The only
exception is that a private method or constructor may 
be marked with the <CODE>helper</CODE> modifier; such methods cannot assume
and do not need to establish the invariant.

<H3><A NAME="FOOT10" HREF="prelimdesign_2.html#DOCF10">(10)</A></H3>
<P> For historical reasons, one
can also use the keyword <CODE>modifiable</CODE> as a synonym for
<CODE>assignable</CODE>.  Also, for compatibility with (older versions of)
ESC/Java <A HREF="prelimdesign_6.html#BIB51">[Leino-etal00]</A>, in JML, one can also use the keyword
<CODE>modifies</CODE> as a synonym for <CODE>assignable</CODE>.  In the
literature, the most common keyword for such a clause is
<CODE>modifies</CODE>, and what JML calls the "assignable clause" is
usually referred to as a "modifies clause".  However, in JML,
"assignable" most closely corresponds to the technical meaning, so
we use that throughout this document.  Users of JML may write
whichever they prefer, and may mix them if they please.
<H3><A NAME="FOOT11" HREF="prelimdesign_2.html#DOCF11">(11)</A></H3>
<P>Assuming that <CODE>x</CODE> is not
the same object as <CODE>this</CODE>!
<H3><A NAME="FOOT12" HREF="prelimdesign_2.html#DOCF12">(12)</A></H3>
<P>
Thanks to Erik Poll for discussions on checking of assignable
clauses.
<H3><A NAME="FOOT13" HREF="prelimdesign_2.html#DOCF13">(13)</A></H3>
<P>
Furthermore, static model fields must have concrete implementations
in the interfaces in which they are declared, if they are to have
any representation at all.
See section <A HREF="prelimdesign_2.html#SEC29">2.2.2.1 Data Groups and Represents Clauses</A>, for more on this subject.

<H3><A NAME="FOOT14" HREF="prelimdesign_2.html#DOCF14">(14)</A></H3>
<P>
The keyword "<CODE>exsures</CODE>" can also be used in place of <CODE>signals</CODE>.
<H3><A NAME="FOOT15" HREF="prelimdesign_2.html#DOCF15">(15)</A></H3>
<P>
Of course, one could specify <CODE>BoundedStackInterface</CODE> without
separating out the interface <CODE>BoundedThing</CODE>,
and in that case, these layers would be unnecessary.
We have made this separation partly to demonstrate more advanced features
of JML, and partly to make the parts of the example smaller.
<H3><A NAME="FOOT16" HREF="prelimdesign_2.html#DOCF16">(16)</A></H3>
<P>
Note that the permission to assign a field goes from the more abstract
field to the one in its group (which in this case is also abstract).
M&uuml;ller points out that
this direction is necessary for information hiding,
because concrete fields are often hidden (e.g., they may
be <CODE>private</CODE>), and as such cannot appear in public specifications,
so the public specification has to mention the more abstract field,
which give assignment rights to its members <A HREF="prelimdesign_6.html#BIB64">[Mueller02]</A>.
<H3><A NAME="FOOT17" HREF="prelimdesign_2.html#DOCF17">(17)</A></H3>
<P>
Thanks to Erik Poll for pointing this out.
<H3><A NAME="FOOT18" HREF="prelimdesign_2.html#DOCF18">(18)</A></H3>
<P>
Meyer's second specification and implementation of stacks
(see page 349 of <A HREF="prelimdesign_6.html#BIB60">[Meyer97]</A>) is no better in this respect,
although, of course, the implementation does keep track of the elements
properly.
<H3><A NAME="FOOT19" HREF="prelimdesign_2.html#DOCF19">(19)</A></H3>
<P>
There is no use of <CODE>initially</CODE> in this interface,
so data type induction cannot assume any particular starting value.
But this is desirable, since if a particular starting value was
specified, then by the history constraint, all objects would have
that value.
<H3><A NAME="FOOT20" HREF="prelimdesign_2.html#DOCF20">(20)</A></H3>
<P>
One may also give <CODE>exceptional_example</CODE> clauses,
which are analogous to <CODE>exceptional_behavior</CODE> specifications,
and <CODE>example</CODE> clauses, which are analogous to <CODE>behavior</CODE>
specifications. 
There is also a lightweight form of example, this is
similar to the <CODE>example</CODE> form, except that the introductory keywords
"<CODE>public example</CODE>" are omitted.
<H3><A NAME="FOOT21" HREF="prelimdesign_2.html#DOCF21">(21)</A></H3>
<P>
<EM>Observable aliasing</EM>
is a sharing relation between objects that can be detected by a program.
Such a program, might, for example modify one object and read a changed value
from the shared object.
Formalizing this in general is beyond the scope of this paper,
and probably beyond what JML can describe.

<H3><A NAME="FOOT22" HREF="prelimdesign_2.html#DOCF22">(22)</A></H3>
<P>
This <CODE>represents</CODE> clause is implicitly an instance, as opposed to
a static, represents clause, because it appears in a class
declaration.

<H3><A NAME="FOOT23" HREF="prelimdesign_2.html#DOCF23">(23)</A></H3>
<P>
As of JDK 1.4, <CODE>assert</CODE> is also a reserved word in Java.
One can thus write assert statements either in standard Java or in
JML annotations.
If one writes an assert statement as a JML annotation,
all of the JML extensions to the Java expression syntax 
see section <A HREF="prelimdesign_3.html#SEC50">3.1 Extensions to Java Expressions for Predicates</A>
for the predicate can be used,
but no side-effects are allowed in this predicate.
Such a JML <A HREF="#assert-statement"><VAR>assert-statement</VAR></A> may also refer to model and ghost variables.
In a Java assert statement, i.e., in an <A HREF="#assert-statement"><VAR>assert-statement</VAR></A> that
is not in an annotation, one cannot use JML's extensions for assertions,
because such assertions must compile with a Java compiler.

<H3><A NAME="FOOT24" HREF="prelimdesign_2.html#DOCF24">(24)</A></H3>
<P>
When such private and default visibility specification cases are
visible to callers, they may only be 
used in verification of a method call if the call can be shown to be
executing that method, as opposed to some override.

<H3><A NAME="FOOT25" HREF="prelimdesign_2.html#DOCF25">(25)</A></H3>
<P>
However, textual copying shouldn't be taken literally;
if a subclass declares a field that hides the fields of its superclass,
renaming must be done to prevent name capture.
<H3><A NAME="FOOT26" HREF="prelimdesign_3.html#DOCF26">(26)</A></H3>
<P>
Suppose <I>A</I> is the superclass of <I>B</I>, and <I>B</I> is the superclass of <I>C</I>.
Suppose <I>B</I>'s specification used <CODE>super</CODE> to call a method of <I>A</I>.
The problem is that when this specification is inherited by <I>C</I>,
if we imagine copying <I>B</I>'s specification to <I>C</I>,
then this use of <I>super</I> no longer refers to <I>A</I>, but to <I>B</I>.
Thanks to Arnd Poetzsch-Heffter for pointing out this problem.

<H3><A NAME="FOOT27" HREF="prelimdesign_3.html#DOCF27">(27)</A></H3>
<P>
Note that it is wrong to use <CODE>\fresh(this)</CODE> in the specification
of a constructor, because Java's <CODE>new</CODE> operator allocates storage
for the object; the constructor's job is just to initialize that
storage.

<HR SIZE=1>
<BR>  
<FONT SIZE="-1">
This document was generated
by <I>Gary Leavens</I> on <I>January, 9  2008</I>
using <A HREF="http://www.mathematik.uni-kl.de/~obachman/Texi2html
"><I>texi2html</I></A>

</BODY>
</HTML>
