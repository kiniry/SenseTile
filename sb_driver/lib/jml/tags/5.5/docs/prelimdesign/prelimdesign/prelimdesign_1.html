<HTML>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<!-- Created on January, 9  2008 by texi2html 1.64 -->
<!-- 
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Olaf Bachmann <obachman@mathematik.uni-kl.de>
Send bugs and suggestions to <texi2html@mathematik.uni-kl.de>
 
-->
<HEAD>
<TITLE>Preliminary Design of JML: Introduction</TITLE>

<META NAME="description" CONTENT="Preliminary Design of JML: Introduction">
<META NAME="keywords" CONTENT="Preliminary Design of JML: Introduction">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<META NAME="Generator" CONTENT="texi2html 1.64">

</HEAD>

<BODY LANG="" BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#0000FF" VLINK="#800080" ALINK="#FF0000">

<A NAME="SEC1"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="prelimdesign.html#SEC_Top"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="prelimdesign_2.html#SEC11"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="prelimdesign.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="prelimdesign_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="prelimdesign_7.html#SEC56">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="prelimdesign_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>

<HR SIZE=2>
<A NAME="Introduction"></A>
<H1> 1. Introduction </H1>
<!--docid::SEC1::-->
<P>

<center>
 <B>Abstract</B>
</center>
</P><P>

<BLOCKQUOTE>
JML is a behavioral interface specification language tailored to Java(TM).
Besides pre- and postconditions,
it also allows assertions to be intermixed with Java code; these aid
verification and debugging.  JML is designed to be used by working
software engineers; to do this it follows Eiffel in using Java
expressions in assertions.  JML combines this idea from Eiffel with the
model-based approach to specifications, typified by VDM and Larch,
which results in greater expressiveness.  Other expressiveness
advantages over Eiffel include quantifiers, specification-only
variables, and frame conditions.
<P>

This paper discusses the goals of JML, the overall approach, and
describes the basic features of the language through examples.  It is
intended for readers who have some familiarity with both Java and
behavioral specification using pre- and postconditions.
</BLOCKQUOTE>
<P>

<A NAME="IDX1"></A>
<A NAME="IDX2"></A>
<A NAME="IDX3"></A>
<A NAME="IDX4"></A>
<A NAME="IDX5"></A>
<A NAME="IDX6"></A>
<A NAME="IDX7"></A>
<A NAME="IDX8"></A>
<A NAME="IDX9"></A>
<A NAME="IDX10"></A>
<A NAME="IDX11"></A>
<A NAME="IDX12"></A>
JML stands for "Java Modeling Language" <A HREF="prelimdesign_6.html#BIB42">[Leavens-Baker-Ruby99]</A>.
JML is a <EM>behavioral interface specification language</EM> (BISL)
<A HREF="prelimdesign_6.html#BIB83">[Wing87]</A>
designed to specify
Java <A HREF="prelimdesign_6.html#BIB1">[Arnold-Gosling-Holmes00]</A> <A HREF="prelimdesign_6.html#BIB25">[Gosling-etal00]</A> 
modules.
Java <EM>modules</EM> are classes and interfaces.
</P><P>

<A NAME="IDX13"></A>
The main goal of our research on JML is to better understand
how to make BISLs (and BISL tools)
that are practical and effective for production software environments.
In order to understand this goal, and the more detailed discussion
of our goals for JML, it helps to define more precisely what
a behavioral interface specification is.
After doing this, we return
to describing the goals of JML,
and then give a brief overview of the tool support for JML and an
outline of the rest of the paper.
</P><P>

<BLOCKQUOTE><TABLE BORDER=0 CELLSPACING=0> 
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="prelimdesign_1.html#SEC2">1.1 Behavioral Interface Specification</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="prelimdesign_1.html#SEC3">1.2 Lightweight Specifications</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="prelimdesign_1.html#SEC4">1.3 Goals</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="prelimdesign_1.html#SEC5">1.4 Tool Support</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="prelimdesign_1.html#SEC10">1.5 Outline</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
</TABLE></BLOCKQUOTE>
<P>

<A NAME="Behavioral Interface Specification"></A>
<HR SIZE="6">
<A NAME="SEC2"></A>
<H2> 1.1 Behavioral Interface Specification </H2>
<!--docid::SEC2::-->
<P>

<A NAME="IDX14"></A>
<A NAME="IDX15"></A>
<A NAME="IDX16"></A>
<A NAME="IDX17"></A>
As a BISL,
JML describes two important aspects of a Java module:
<UL>
<LI>
its <EM>interface</EM>, which consists of the names and static information
found in Java declarations,
and
<P>

<LI>
its <EM>behavior</EM>, which tells how the module acts when used.
</UL>
<P>

<A NAME="IDX18"></A>
<A NAME="IDX19"></A>
<A NAME="IDX20"></A>
BISLs are inherently language-specific <A HREF="prelimdesign_6.html#BIB83">[Wing87]</A>,
because they describe interface details for clients written in a specific
programming language,
For example, a BISL tailored to C++, such as Larch/C++ <A HREF="prelimdesign_6.html#BIB38">[Leavens97c]</A>,
describes how to use a module in a C++ program.
A Larch/C++ specification cannot be implemented correctly in Java,
and a JML specification cannot be correctly implemented in C++
(except for methods that are specified as native code).
</P><P>

<A NAME="IDX21"></A>
<A NAME="IDX22"></A>
<A NAME="IDX23"></A>
<A NAME="IDX24"></A>
<A NAME="IDX25"></A>
JML specifications can either be written in separate files
or as annotations in Java program files.
To a Java compiler such annotations are comments that are ignored
<A HREF="prelimdesign_6.html#BIB56">[Luckham-vonHenke85]</A> <A HREF="prelimdesign_6.html#BIB57">[Luckham-etal87]</A> <A HREF="prelimdesign_6.html#BIB71">[Rosenblum95]</A> <A HREF="prelimdesign_6.html#BIB77">[Tan94]</A> <A HREF="prelimdesign_6.html#BIB78">[Tan95]</A>.
This allows JML specifications, such as the specification below,
to be embedded in Java program files.
Consider the following
simple example of a behavioral interface specification in JML,
written as annotations in a Java program file, <TT>`IntMathOps.java'</TT>.
</P><P>

<A NAME="IDX26"></A>
<A NAME="IDX27"></A>
<TABLE><tr><td>&nbsp;</td><td class=example><pre>
public class IntMathOps {                                // 1
                                                         // 2
  /*@ public normal_behavior                             // 3
    @   requires y &#62;= 0;                                 // 4
    @   assignable \nothing;                             // 5
    @   ensures 0 &#60;= \result                             // 6
    @        &#38;&#38; \result * \result &#60;= y                   // 7
    @        &#38;&#38; ((0 &#60;= (\result + 1) * (\result + 1))    // 8
    @            ==&#62; y &#60; (\result + 1) * (\result + 1)); // 9
    @*/                                                  //10
  public static int isqrt(int y)                         //11
  {                                                      //12
    return (int) Math.sqrt(y);                           //13
  }                                                      //14
}                                                        //15
</pre></td></tr></table></P><P>

<A NAME="IDX28"></A>
<A NAME="IDX29"></A>
<A NAME="IDX30"></A>
<A NAME="IDX31"></A>
The specification above describes a Java class, <CODE>IntMathOps</CODE>
that contains one static method (function member) named <CODE>isqrt</CODE>.
The single-line comments to the far right (which start with <CODE>//</CODE>)
give the line numbers in this specification;
they are ignored by both Java and JML.
Comments with an immediately following at-sign, <CODE>//@</CODE>,
or, as on lines 3--10, C-style comments
starting with <CODE>/*@</CODE>, are <EM>annotations</EM>.
Annotations are treated as comments by a Java compiler,
but JML processes the text of an annotation.
The text of an annotation is either the remainder of a line
following <CODE>//@</CODE>
or the characters between the annotation markers <CODE>/*@</CODE> and <CODE>@*/</CODE>.
In the second form, at-signs (<CODE>@</CODE>) at the beginning of lines
are ignored;
they can be used to help the reader see the extent of an annotation.
</P><P>

In the above specification,
interface information is declared in lines 1 and 11.
Line 1 declares a class named <CODE>IntMathOps</CODE>,
and line 11 declares a method named <CODE>isqrt</CODE>.
Note that all of Java's declaration syntax is allowed in JML,
including, on lines 1 and 11, that the names declared are <CODE>public</CODE>,
that the method is <CODE>static</CODE> (line 11),
that its return type is <CODE>int</CODE> (line 11),
and that it takes one <CODE>int</CODE> argument.
</P><P>

<A NAME="IDX32"></A>
Such interface declarations must be found in a Java module
that correctly implements this specification.
This is automatically the case in the file <TT>`IntMathOps.java'</TT>
shown above, since that file also contains the implementation.
In fact, when Java annotations are embedded in <TT>`.java'</TT> files,
the interface specification is the actual Java source code.
</P><P>

<A NAME="IDX33"></A>
<A NAME="IDX34"></A>
<A NAME="IDX35"></A>
<A NAME="IDX36"></A>
To be correct, an implementation must have both the specified interface
and the specified behavior.
In the above specification,
the behavioral information is specified in the annotation text
on lines 3--10.<A NAME="DOCF1" HREF="prelimdesign_fot.html#FOOT1">(1)</A>
The keywords <CODE>public normal_behavior</CODE> are used to say that
the specification is intended for callers (hence "public"),
and that when the precondition is satisfied
a call must return normally, without throwing an exception (hence "normal").
In such a public specification, only names with public visibility
may be used.<A NAME="DOCF2" HREF="prelimdesign_fot.html#FOOT2">(2)</A>
<A NAME="IDX37"></A>
<A NAME="IDX38"></A>
<A NAME="IDX39"></A>
<A NAME="IDX40"></A>
<A NAME="IDX41"></A>
<A NAME="IDX42"></A>
On line 4 is a precondition, which follows the keyword
<CODE>requires</CODE>.<A NAME="DOCF3" HREF="prelimdesign_fot.html#FOOT3">(3)</A>
On line 5 is frame condition, which says that this method, when called,
does not assign to any locations.
On lines 6--9 is a postcondition,
which follows the keyword <CODE>ensures</CODE>.<A NAME="DOCF4" HREF="prelimdesign_fot.html#FOOT4">(4)</A>
The precondition says what must be true about the arguments
(and other parts of the state);
if the precondition is true, then the method must terminate normally
in a state that satisfies the postcondition.
<A NAME="IDX43"></A>
<A NAME="IDX44"></A>
<A NAME="IDX45"></A>
<A NAME="IDX46"></A>
<A NAME="IDX47"></A>
<A NAME="IDX48"></A>
<A NAME="IDX49"></A>
<A NAME="IDX50"></A>
This is a contract between the caller of the method and the implementor
<A HREF="prelimdesign_6.html#BIB29">[Hoare69]</A> <A HREF="prelimdesign_6.html#BIB34">[Jones90]</A> <A HREF="prelimdesign_6.html#BIB35">[Jonkers91]</A> <A HREF="prelimdesign_6.html#BIB27">[Guttag-Horning93]</A> <A HREF="prelimdesign_6.html#BIB58">[Meyer92a]</A> <A HREF="prelimdesign_6.html#BIB60">[Meyer97]</A> <A HREF="prelimdesign_6.html#BIB61">[Morgan94]</A>.
The caller is obligated to make the precondition true,
and gets the benefit of having the postcondition then be satisfied.
The implementor gets the benefit of being able to assume the precondition,
and is obligated to make the postcondition true in that case.
</P><P>

<A NAME="IDX51"></A>
<A NAME="IDX52"></A>
<A NAME="IDX53"></A>
In general, pre- and postconditions in JML are written using an
extended form of Java expressions.
In this case, the only extension visible is the keyword <CODE>\result</CODE>,
which is used in the postcondition to denote the value returned by the method.
The type of <CODE>\result</CODE> is the return type of the method;
for example, the type of <CODE>\result</CODE> in <CODE>isqrt</CODE> is
<CODE>int</CODE>.
The postcondition says that the result is an integer approximation to the
square root of <CODE>y</CODE>.  The first conjunct on line 6,
<CODE>0 &#60;= \result</CODE>
say that the result is non-negative.
The second and third conjuncts state that the result is an integer
approximation to the square root of the argument <CODE>y</CODE>.
The second conjunct, on line 7, says that the result squared is no
larger than the argument, <CODE>y</CODE>.
The third conjunct, on lines
8--9, is an implication; it has two expressions connected by
<CODE>==&#62;</CODE>, which means implication in JML.
This implication says that if the result plus one squared is
non-negative, then the result plus one squared is strictly larger than
<CODE>y</CODE>.<A NAME="DOCF5" HREF="prelimdesign_fot.html#FOOT5">(5)</A>
Note that the behavioral specification does not give an algorithm for finding
the square root.
</P><P>

<A NAME="IDX54"></A>
<A NAME="IDX55"></A>
<A NAME="IDX56"></A>
<A NAME="IDX57"></A>
<A NAME="IDX58"></A>
<A NAME="IDX59"></A>
<A NAME="IDX60"></A>
<A NAME="IDX61"></A>
<A NAME="IDX62"></A>
<A NAME="IDX63"></A>
<A NAME="IDX64"></A>
Method specifications may also be written in Java's documentation comments.
The following is an example.  The part that JML sees is enclosed within
the HTML "tags" <CODE>&#60;jml&#62;</CODE> and <CODE>&#60;/jml&#62;</CODE>.<A NAME="DOCF6" HREF="prelimdesign_fot.html#FOOT6">(6)</A>
As in this example, one can use surrounding
tags <CODE>&#60;pre&#62;</CODE> and <CODE>&#60;/pre&#62;</CODE> to tell javadoc to ignore what JML sees,
and to leave the formatting of it alone.  The <CODE>&#60;pre&#62;</CODE> and <CODE>&#60;/pre&#62;</CODE>
tags are not 
required by JML tools (including jmldoc, which does a better job of formatting
specifications than does javadoc).
</P><P>

<A NAME="IDX65"></A>
<TABLE><tr><td>&nbsp;</td><td class=example><pre>
public class IntMathOps4 { 

  /** Integer square root function.
   * @param y the number to take the root of
   * @return an integer approximating
   *         the positive square root of y
   * &#60;pre&#62;&#60;jml&#62;
   *   public normal_behavior
   *     requires y &#62;= 0;   
   *     assignable \nothing; 
   *     ensures 0 &#60;= \result
   *        &#38;&#38; \result * \result &#60;= y
   *        &#38;&#38; ((0 &#60;= (\result + 1) * (\result + 1))
   *            ==&#62; y &#60; (\result + 1) * (\result + 1));
   * &#60;/jml&#62;&#60;/pre&#62;
   **/
  public static int isqrt(int y)
  {
     return (int) Math.sqrt(y);
  }
}
</pre></td></tr></table></P><P>

<A NAME="IDX66"></A>
<A NAME="IDX67"></A>
<A NAME="IDX68"></A>
Because we expect most of our users to write specifications in Java
code files, most of our examples will be given as annotations
in <TT>`.java'</TT> files as in the specifications above.
However, it is possible to use JML to write documentation in separate,
non-Java files,
such as the file <TT>`IntMathOps2.jml-refined'</TT> below.
Since these files are not Java program files,
JML requires the user to omit the code for concrete methods in such a
file (except that code for "model" methods can be present,
see section <A HREF="prelimdesign_2.html#SEC35">2.3.1 Purity</A>).
The specification below shows how this is done, using a semicolon (<CODE>;</CODE>),
as in a Java abstract method declaration.
</P><P>

<A NAME="IDX69"></A>
<TABLE><tr><td>&nbsp;</td><td class=example><pre>
//@ model import org.jmlspecs.models.*;

public /*+@ spec_bigint_math @+*/ class IntMathOps2 {

 /*@ public normal_behavior
   @   requires y &#62;= 0;
   @   assignable \nothing;
   @   ensures -y &#60;= \result &#38;&#38; \result &#60;= y;
   @   ensures \result * \result &#60;= y;
   @   ensures y &#60; (Math.abs(\result) + 1)
   @               * (Math.abs(\result) + 1);
   @*/
  public static int isqrt(int y);
}
</pre></td></tr></table></P><P>

<A NAME="IDX70"></A>
<A NAME="IDX71"></A>
<A NAME="IDX72"></A>
<A NAME="IDX73"></A>
<A NAME="IDX74"></A>
Besides files with suffixes of <TT>`.jml-refined'</TT> or <TT>`.jml'</TT>,
JML also works with files with the suffixes <TT>`.spec'</TT>
and <TT>`.spec-refined'</TT>.
All these files use Java's syntax, and one must use annotation markers
just as in a <TT>`.java'</TT> file.
However, since these kinds of files files are not Java files,
in such a file one must also omit the code for concrete, non-model methods.
</P><P>

<A NAME="IDX75"></A>
<A NAME="IDX76"></A>
The specification of <CODE>IntMathOps2</CODE> below
is written in <CODE>spec_bigint_math</CODE> mode <A HREF="prelimdesign_6.html#BIB12">[Chalin04]</A>.
This means that integer mathematics inside the specifications in the
class <CODE>IntMathOps2</CODE> are done in infinite precision arithmetic,
instead of the usual Java arithmetic.  This leads to a simpler
specification, especially in the ensures clause.<A NAME="DOCF7" HREF="prelimdesign_fot.html#FOOT7">(7)</A>
</P><P>

<A NAME="IDX78"></A>
<A NAME="IDX79"></A>
The above specification also demonstrates that ensures clauses can be
repeated in a specification.  In <CODE>IntMathOps2</CODE>'s specification of
<CODE>isqrt</CODE>, there are three ensures clauses; all of them must be
satisfied. Thus the meaning is the same as the conjunction of all of
the postconditions specified in the individual ensures clauses.
This specification is also more underspecified than the specifications
given previously, as it allows negative numbers to be returned as results.
</P><P>

<A NAME="IDX80"></A>
The above specification would be implemented
in the file <TT>`IntMathOps2.java'</TT>,
which is shown below.
This file contains a <CODE>refine</CODE> clause,
which tells the reader of the <TT>`.java'</TT>
file what is being refined
and the file in which to find its specification.
</P><P>

<A NAME="IDX81"></A>
<TABLE><tr><td>&nbsp;</td><td class=example><pre>
//@ refine "IntMathOps2.jml-refined";

//@ model import org.jmlspecs.models.*;

public class IntMathOps2 {

  public static int isqrt(int y)
  {
     return (int) Math.sqrt(y);
  }
}
</pre></td></tr></table></P><P>

To summarize, a behavioral interface specification describes both the
interface details of a module, and its behavior.
The interface details are written in the syntax of the programming language;
thus JML uses the Java declaration syntax.
The behavioral specification uses pre- and postconditions.
</P><P>

<A NAME="Lightweight Specifications"></A>
<HR SIZE="6">
<A NAME="SEC3"></A>
<H2> 1.2 Lightweight Specifications </H2>
<!--docid::SEC3::-->
<P>

<A NAME="IDX82"></A>
<A NAME="IDX83"></A>
<A NAME="IDX84"></A>
Although we find it best to illustrate JML's features in this paper using
specifications that are detailed and complete, one
can use JML to write less detailed specifications.
In particular, one can use JML to write "lightweight"
specifications (as in ESC/Java).  The syntax of JML allows one to write
specifications that consist of individual clauses, so that one can say
just what is desired.  More precisely, a <EM>lightweight</EM> specification
is one that does not use a behavior keyword  (like
<CODE>normal_behavior</CODE>).
By way of contrast, we call a specification a <EM>heavyweight</EM>
specification if it uses one of the behavior keywords.
</P><P>

For example, one might wish to specify just that <CODE>isqrt</CODE>
should be called only on positive arguments, but not want to be
bothered with saying anything formal about the locations
that can be assigned to by the method or about the result.
This could be done as shown below.
Notice that the only specification given below is
a single <CODE>requires</CODE> clause.
Since the specification of <CODE>isqrt</CODE> has no behavior keyword,
it is a lightweight specification.
</P><P>

<A NAME="IDX85"></A>
<TABLE><tr><td>&nbsp;</td><td class=example><pre>
public class IntMathOps3 {

  //@ requires y &#62;= 0;
  public static int isqrt(int y)
  {
    return (int) Math.sqrt(y);
  }
}
</pre></td></tr></table></P><P>

<A NAME="IDX86"></A>
<A NAME="IDX87"></A>
<A NAME="IDX88"></A>
What is the access restriction, or privacy level,
of such a lightweight specification?
The syntax for lightweight specifications does not
have a place to specify the privacy level,
so JML assumes that such a lightweight specification
has the same level of visibility as the method itself.
(Thus, the specification below is implicitly <CODE>public</CODE>.)
What about the omitted parts of the specification, such as the ensures clause?
JML assumes nothing about these.
In the example below when the precondition is met,
an implementation might either signal an
exception or terminate normally, so this specification technically
allows exceptions to be thrown. However, the gain in brevity often
outweighs the need for this level of precision.
</P><P>

<A NAME="IDX89"></A>
<A NAME="IDX90"></A>
JML has a semantics that allows most clauses to be sensibly omitted
from a specification.  When the <CODE>requires</CODE> clause is omitted, for
example, it means that no requirements are placed on the caller.  When
the <CODE>assignable</CODE> clause is omitted, it means that nothing is
promised about what locations may not be assigned to by the method;
that is, the method may assign to all locations that it can otherwise
legally assign to.  When the <CODE>ensures</CODE> clause is omitted, it
means that nothing is promised about the state resulting from a method
call.  See section <A HREF="prelimdesign_5.html#SEC54">A. Specification Case Defaults</A>, for the default meanings of
various other clauses.
</P><P>

<A NAME="Goals"></A>
<HR SIZE="6">
<A NAME="SEC4"></A>
<H2> 1.3 Goals </H2>
<!--docid::SEC4::-->
<P>

<A NAME="IDX91"></A>
As mentioned above,
the main goal of our research is to better understand
how to develop BISLs (and BISL tools)
that are practical and effective.
We are concerned with both technical requirements
and with other factors such as training and documentation,
although in the rest of this paper we will only be concerned with
technical requirements for the BISL itself.
The practicality and
effectiveness of JML will be judged by how well
it can document reusable class libraries, frameworks, and
Application Programming Interfaces (APIs).
</P><P>

We believe that to meet the overall goal of practical and effective
behavioral interface specification,
JML must meet the following subsidiary goals.
<UL>
<LI>
JML must be able to document the interfaces and behavior of existing software,
regardless of the analysis and design methods used to create it.
<P>

If JML were limited to only handling certain Java features,
certain kinds of software, or software designed according to certain
analysis and design methods,
then some APIs would not be amenable to documentation using JML.
This would mean that some existing software could not be documented
using JML.
Since the effort put into writing such documentation will have a proportionally
larger payoff for software that is more widely reused,
it is important to be able to document existing software components.
</P><P>

(However, it should be noted that we make some exceptions to this goal.
One is that JML requires that all subtypes be behavioral subtypes
<A HREF="prelimdesign_6.html#BIB19">[Dhara-Leavens96]</A> <A HREF="prelimdesign_6.html#BIB38">[Leavens97c]</A> <A HREF="prelimdesign_6.html#BIB83">[Wing87]</A> of their supertypes.
This is done because otherwise one cannot reason modularly about
programs that use subtyping and dynamic dispatch.
Another is that we specify <CODE>Object</CODE>'s method <CODE>equals</CODE> as a
pure method, which prohibits even benevolent side effects in any
<CODE>equals</CODE> method that takes an <CODE>Object</CODE> as an argument.  This
is done to permit purity checking for collection classes that contain
objects as members and use <CODE>equals</CODE> to compare them, as in the
collection types found in <CODE>java.util</CODE>.)
</P><P>

<LI>
The notation used in JML should be readily understandable by Java programmers,
including those with only standard mathematical training.
<P>

<A NAME="IDX92"></A>
<A NAME="IDX93"></A>
<A NAME="IDX94"></A>
<A NAME="IDX95"></A>
<A NAME="IDX96"></A>
<A NAME="IDX97"></A>
A preliminary study by Finney <A HREF="prelimdesign_6.html#BIB21">[Finney96]</A> indicates that
graphic mathematical notations,
such as those found in Z <A HREF="prelimdesign_6.html#BIB28">[Hayes93]</A> <A HREF="prelimdesign_6.html#BIB75">[Spivey92]</A> <A HREF="prelimdesign_6.html#BIB86">[Woodcock-Davies96]</A>
may make such specifications
hard to read, even for programmers trained in the notation.
This accords with our experience in teaching formal specification notations
to programmers.
Hence, our strategy for meeting this goal has been to shun most special-purpose
mathematical notations in favor of Java's own expression syntax.
</P><P>

<LI>
The language must be capable of being given a rigorous, formal semantics,
and must also be amenable to tool support.
<P>

This goal also helps ensure that the specification language does not suffer
from logical problems, which would make it less useful for
static analysis, prototyping, and testing tools.
</UL>
<P>

<A NAME="IDX98"></A>
<A NAME="IDX99"></A>
<A NAME="IDX100"></A>
<A NAME="IDX101"></A>
We also have in mind a long range goal of a specification compiler,
that would produce prototypes from specifications that happen to be 
constructive <A HREF="prelimdesign_6.html#BIB79">[Wahls-Leavens-Baker00]</A>.
</P><P>

<A NAME="IDX102"></A>
<A NAME="IDX103"></A>
<A NAME="IDX104"></A>
<A NAME="IDX105"></A>
Our partners at Compaq SRC and the
University of Nijmegen have other goals in mind.  At Compaq SRC, the
goal is to make static analysis tools for Java programs that can help
detect bugs.  At the University of Nijmegen, the goal is to be able to
do full program verification on Java programs.
</P><P>

<A NAME="IDX106"></A>
<A NAME="IDX107"></A>
<A NAME="IDX108"></A>
<A NAME="IDX109"></A>
<A NAME="IDX110"></A>
<A NAME="IDX111"></A>
<A NAME="IDX112"></A>
<A NAME="IDX113"></A>
<A NAME="IDX114"></A>
<A NAME="IDX115"></A>
<A NAME="IDX116"></A>
<A NAME="IDX117"></A>
As a general strategy for achieving these goals,
we have tried to blend the Eiffel <A HREF="prelimdesign_6.html#BIB58">[Meyer92a]</A> <A HREF="prelimdesign_6.html#BIB59">[Meyer92b]</A> <A HREF="prelimdesign_6.html#BIB60">[Meyer97]</A>,
Larch <A HREF="prelimdesign_6.html#BIB83">[Wing87]</A> <A HREF="prelimdesign_6.html#BIB84">[Wing90a]</A> <A HREF="prelimdesign_6.html#BIB27">[Guttag-Horning93]</A> <A HREF="prelimdesign_6.html#BIB39">[LeavensLarchFAQ]</A>,
and refinement calculus
<A HREF="prelimdesign_6.html#BIB4">[Back88]</A> <A HREF="prelimdesign_6.html#BIB7">[Back-vonWright98]</A> <A HREF="prelimdesign_6.html#BIB62">[Morgan-Vickers94]</A> <A HREF="prelimdesign_6.html#BIB61">[Morgan94]</A>
approaches to specification.
From Eiffel we have taken the idea that assertions can be written in
a language that is based on Java expressions.
<A NAME="IDX118"></A>
We also adapt the "<CODE>old</CODE>" notation from Eiffel,
which appears in JML as <CODE>\old</CODE>,
instead of the Larch-style annotation of names with state functions.
However, Eiffel specifications, as written by Meyer,
are typically not as detailed as model-based specifications
written, for example, in Larch BISLs or in
<A NAME="IDX119"></A>
<A NAME="IDX120"></A>
<A NAME="IDX121"></A>
<A NAME="IDX122"></A>
<A NAME="IDX123"></A>
VDM-SL <A HREF="prelimdesign_6.html#BIB22">[Fitzgerald-Larsen98]</A> <A HREF="prelimdesign_6.html#BIB32">[ISO96]</A> <A HREF="prelimdesign_6.html#BIB34">[Jones90]</A>.
Hence, we have combined these approaches, by using syntactic ideas
from Eiffel and semantic ideas from model-based specification languages.
</P><P>

<A NAME="IDX124"></A>
<A NAME="IDX125"></A>
<A NAME="IDX126"></A>
<A NAME="IDX127"></A>
<A NAME="IDX128"></A>
<A NAME="IDX129"></A>
JML also has some other differences from Eiffel
(and its cousins Sather and Sather-K).
The most important is the concept of specification-only
declarations.
These declarations allow more abstract and exact specifications of behavior
than is typically done in Eiffel;
they allow one to write specifications that are similar to the spirit of VDM
or Larch BISLs.
A major difference is that we have extended
the syntax of Java expressions with quantifiers and other constructs
that are needed for logical expressiveness, but which are not always
executable.
Finally, we ban side-effects
and other problematic features of code in assertions.
</P><P>

<A NAME="IDX130"></A>
<A NAME="IDX131"></A>
On the other hand,
our experience with Larch/C++ has taught us to adapt
the model-based approach in two ways, with the aim of making it more
practical and easy to learn.
The first adaptation is again the use of specification-only
model variables.
An object will thus have (in general) several such <EM>model fields</EM>,
which are used only for the purpose of describing, abstractly, the values
of objects.
This simplifies the use of JML, as compared with most Larch BISLs,
since specifiers (and their readers)
hardly ever need to know about algebraic-style specification.
It also makes designing a model for a Java class or interface similar,
in some respects, to designing an implementation data structure in Java.
We hope that this similarity
will make the specification language easier to understand.
(This kind of model also has some technical advantages
that will be described below.)
</P><P>

<A NAME="IDX132"></A>
<A NAME="IDX133"></A>
<A NAME="IDX134"></A>
<A NAME="IDX135"></A>
The second adaptation is hiding the details of mathematical
modeling behind a facade of Java classes.
In the Larch approach to behavioral interface specification <A HREF="prelimdesign_6.html#BIB83">[Wing87]</A>,
the mathematical notation used in assertions is presented directly
to the specifier.
This allows the same mathematical notation to be used in many different
specification languages.
However, it also means that the user of such a specification language has to
learn a notation for assertions that is different than their programming
language's notation for expressions.
In JML we use a compromise approach, hiding these details behind Java classes.
These classes have objects with many "pure" methods,
in the sense that they do not use side-effects
(at least not in any observable way).
Such classes are intended to present the underlying
mathematical concepts using Java syntax.
Besides insulating the user of JML from the details of the mathematical
notation, this compromise approach also insulates the design of JML
from the details of the mathematical logic used for theorem proving.
</P><P>

<A NAME="IDX136"></A>
<A NAME="IDX137"></A>
<A NAME="IDX138"></A>
<A NAME="IDX139"></A>
<A NAME="IDX140"></A>
<A NAME="IDX141"></A>
<A NAME="IDX142"></A>
We have generally taken features wholesale from the refinement calculus
<A HREF="prelimdesign_6.html#BIB4">[Back88]</A> <A HREF="prelimdesign_6.html#BIB7">[Back-vonWright98]</A> <A HREF="prelimdesign_6.html#BIB62">[Morgan-Vickers94]</A> <A HREF="prelimdesign_6.html#BIB61">[Morgan94]</A>.
Our adaptation of it consists in blending it with the idea
of interface specification and adding features for object-oriented programming.
We are using the adaptation of the refinement calculus by
B&uuml;chi and Weck <A HREF="prelimdesign_6.html#BIB9">[Buechi-Weck00]</A>,
which helps in specifying callbacks.
However, since the refinement calculus is mostly needed for advanced
specifications, in the remainder of this paper 
we do not discuss the JML features related to refinement,
such as model programs.
</P><P>

<A NAME="Tool Support"></A>
<HR SIZE="6">
<A NAME="SEC5"></A>
<H2> 1.4 Tool Support </H2>
<!--docid::SEC5::-->
<P>

<A NAME="IDX143"></A>
<A NAME="IDX144"></A>
<A NAME="IDX145"></A>
Our partners at
Compaq SRC have built a tool, ESC/Java, that does static analysis
for Java programs <A HREF="prelimdesign_6.html#BIB51">[Leino-etal00]</A>.
ESC/Java uses a subset of the JML specification syntax,
to help detect bugs in Java code.
<A NAME="IDX146"></A>
<A NAME="IDX147"></A>
<A NAME="IDX148"></A>
<A NAME="IDX149"></A>
<A NAME="IDX150"></A>
At the University of Nijmegen the LOOP tool <A HREF="prelimdesign_6.html#BIB31">[Huisman01]</A> <A HREF="prelimdesign_6.html#BIB33">[Jacobs-etal98]</A> 
is being adapted to use JML
as its input language.  This tool would generate verification conditions
that could be checked using a theorem prover such as PVS or Isabelle/HOL.
<A NAME="IDX151"></A>
<A NAME="IDX152"></A>
<A NAME="IDX153"></A>
At the Massachusetts Institute of Technology (MIT),
the Daikon invariant detector project <A HREF="prelimdesign_6.html#BIB20">[Ernst-etal01]</A>
is using a subset of JML to record invariants detected by runs of a program.
Recent work uses ESC/Java to validate the invariants that are found.
</P><P>

<A NAME="IDX154"></A>
<A NAME="IDX155"></A>
<A NAME="IDX156"></A>
<A NAME="IDX157"></A>
<A NAME="IDX158"></A>
In the rest of the section we concentrate on the tool support found in
the JML release from Iowa State.
Iowa State's JML release
has tool support for: static type checking of specifications,
run-time assertion checking, generation of HTML pages,
and generation of unit testing harnesses.
Use a web browser on the <TT>`JML.html'</TT> file in the Iowa State JML release
to access more detailed documentation on these tools.
</P><P>

<BLOCKQUOTE><TABLE BORDER=0 CELLSPACING=0> 
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="prelimdesign_1.html#SEC6">1.4.1 Type Checking Specifications</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="prelimdesign_1.html#SEC7">1.4.2 Generating HTML Documentation</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="prelimdesign_1.html#SEC8">1.4.3 Run Time Assertion Checking</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="prelimdesign_1.html#SEC9">1.4.4 Unit Testing with JML</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
</TABLE></BLOCKQUOTE>
<P>

<A NAME="Type Checking Specifications"></A>
<HR SIZE="6">
<A NAME="SEC6"></A>
<H3> 1.4.1 Type Checking Specifications </H3>
<!--docid::SEC6::-->
<P>

<A NAME="IDX159"></A>
<A NAME="IDX160"></A>
<A NAME="IDX161"></A>
<A NAME="IDX162"></A>
<A NAME="IDX163"></A>
Details on how to run the JML checker can be found in its manual page,
which is part of the JML release.
Here we only indicate the most basic uses of the
checker.  Running the checker with filenames as arguments will perform
type checking on all the specifications contained in the given files.
For example, one could check the specifications in the file
<TT>`UnboundedStack.java'</TT> by executing the following command.
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>   jml UnboundedStack.java
</pre></td></tr></table></P><P>

One can also pass several files to the checker.
For example, the following shows a handy pattern to catch all of the JML
files in the current directory.
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>   jml *.*j* *.*spec*
</pre></td></tr></table></P><P>

<A NAME="IDX164"></A>
One can also pass directories to the JML checker, for example
the following will check all the specifications in the current directory.
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>   jml .
</pre></td></tr></table></P><P>

<A NAME="IDX165"></A>
By default, the checker does not recurse into subdirectories, but this
can be changed by using the -R option.  For example, the following
checks specifications in the current directory and all subdirectories.
<TABLE><tr><td>&nbsp;</td><td class=example><pre>   jml -R .
</pre></td></tr></table></P><P>

<A NAME="IDX166"></A>
<A NAME="IDX167"></A>
<A NAME="IDX168"></A>
<A NAME="IDX169"></A>
<A NAME="IDX170"></A>
<A NAME="IDX171"></A>
<A NAME="IDX172"></A>
<A NAME="IDX173"></A>
<A NAME="IDX174"></A>
<A NAME="IDX175"></A>
<A NAME="IDX176"></A>
<A NAME="IDX177"></A>
<A NAME="IDX178"></A>
<A NAME="IDX179"></A>
<A NAME="IDX180"></A>
<A NAME="IDX181"></A>
<A NAME="IDX182"></A>
<A NAME="IDX183"></A>
<A NAME="IDX184"></A>
<A NAME="IDX185"></A>
To allow specifications to be split into several files and to allow
documentation of code without changing existing files,
the checker recognizes several filename suffixes.
The checker recognizes several filename suffixes.
The following are considered to be "active" suffixes:
<TT>`.refines-java'</TT>, <TT>`.refines-spec'</TT>, <TT>`.refines-jml'</TT>,
<TT>`.java'</TT>, <TT>`.spec'</TT>, and <TT>`.jml'</TT>;
There are also three "passive" suffixes:
<TT>`.java-refined'</TT>, <TT>`.spec-refined'</TT>, and <TT>`.jml-refined'</TT>.
Files with passive suffixes can be used in refinements
(see section <A HREF="prelimdesign_1.html#SEC2">1.1 Behavioral Interface Specification</A>)
but should not normally be passed explicitly to the checker
on its command line.
Graphical user interface tools for JML should, by default,
only present the active suffixes for selection.
Among files in a directory with the same prefix,
but with different active suffixes, the one whose suffix appears first
in the list of active suffixes above should be considered primary
by such a tool.
</P><P>

<A NAME="IDX186"></A>
Files with different suffixes should be connected to each other using
<CODE>refines</CODE> clauses.  We give several examples in the remainder
of this paper.
</P><P>

<A NAME="Generating HTML Documentation"></A>
<HR SIZE="6">
<A NAME="SEC7"></A>
<H3> 1.4.2 Generating HTML Documentation </H3>
<!--docid::SEC7::-->
<P>

<A NAME="IDX187"></A>
<A NAME="IDX188"></A>
<A NAME="IDX189"></A>
<A NAME="IDX190"></A>
To generate HTML documentation that can be browsed on the web, 
one uses the <CODE>jmldoc</CODE> tool.<A NAME="DOCF8" HREF="prelimdesign_fot.html#FOOT8">(8)</A>
This tool is a replacement for <CODE>javadoc</CODE> that understands JML
specifications.
In addition to generating web pages for JML files and for JML
annotated Java files,
<CODE>jmldoc</CODE> also generates the indexes and other HTML files that
surround these and provide access, in the same way that <CODE>javadoc</CODE> does.
</P><P>

For example, here is how we use <CODE>jmldoc</CODE> to generate the HTML pages for
the MultiJava project. 
<TABLE><tr><td>&nbsp;</td><td class=example><pre>rm -fr $HOME/MJ/javadocs
jmldoc -Q -private -d $HOME/MJ/javadocs \
  -link file:/cygwin/usr/local/jdk1.4/docs/api \
  -link file:/cygwin/usr/local/antlr/javadocs \
  --sourcepath $HOME/MJ  \
  org.multijava.dis org.multijava.javadoc org.multijava.mjc \
  org.multijava.mjdoc org.multijava.util org.multijava.util.backend \
  org.multijava.util.classfile org.multijava.util.compiler \
  org.multijava.util.jperf org.multijava.util.lexgen \
  org.multijava.util.msggen org.multijava.util.optgen \
  org.multijava.util.optimize org.multijava.util.testing
</pre></td></tr></table></P><P>

The options used in the above invocation of <CODE>jmldoc</CODE> make jmldoc be
quiet (<CODE>-Q</CODE>), document all members (including private ones) of classes and
interfaces (<CODE>-private</CODE>),  write the HTML files relative to
<TT>`$HOME/MJ/javadocs'</TT> (<CODE>-d</CODE>), link
to existing HTML files for the JDK and for ANTLR (<CODE>-link</CODE>),
and find listed packages relative to <TT>`$HOME/MJ'</TT>
(<CODE>--sourcepath</CODE>).
More details on running <CODE>jmldoc</CODE> are available from its manual
page, which is part of the JML release.
</P><P>

<A NAME="Run Time Assertion Checking"></A>
<HR SIZE="6">
<A NAME="SEC8"></A>
<H3> 1.4.3 Run Time Assertion Checking </H3>
<!--docid::SEC8::-->
<P>

<A NAME="IDX191"></A>
<A NAME="IDX192"></A>
<A NAME="IDX193"></A>
<A NAME="IDX194"></A>
<A NAME="IDX195"></A>
<A NAME="IDX196"></A>
<A NAME="IDX197"></A>
<A NAME="IDX198"></A>
The JML runtime assertion checking compiler is called <CODE>jmlc</CODE>.
It type checks assertions (so there is no need to run <CODE>jml</CODE>
separately), and then generates a class file with the executable parts
of the specified assertions, invariants, preconditions, and postconditions
(and other JML constructs)
checked at run-time.
Its basic usage is similar to a Java compiler, as shown in
the following example.
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>   jmlc TestUnboundedStack.java UnboundedStack.java
</pre></td></tr></table></P><P>

This will produce output telling what the compiler is doing, as well
as class files
<TT>`TestUnboundedStack.class'</TT> and <TT>`UnboundedStack.class'</TT>.
</P><P>

<A NAME="IDX199"></A>
To run or test a program compiled with <CODE>jmlc</CODE>, you should use the 
script <CODE>jmlrac</CODE>.  The <CODE>jmlrac</CODE> script
runs the resulting code with a <CODE>CLASSPATH</CODE>
that includes various JAR files containing code needed for run-time assertion
checking. The following is an example.
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>   jmlrac org.jmlspecs.samples.stacks.TestUnboundedStack
</pre></td></tr></table></P><P>

Using the <CODE>jmlrac</CODE> script is necessary.
If you do not use <CODE>jmlrac</CODE> to run the program, you will
get errors, since the code that <CODE>jmlc</CODE> compiles expects various
runtime library classes to be available.
</P><P>

<A NAME="IDX200"></A>
More details on invoking <CODE>jmlc</CODE> and <CODE>jmlrac</CODE> are available
from their manual pages, which are available in the JML release.
See also the <TT>`README.html'</TT> file in the JML release for more
details and troubleshooting tips.
Details on the implementation of <CODE>jmlc</CODE> are found in a paper by
Cheon and Leavens <A HREF="prelimdesign_6.html#BIB15">[Cheon-Leavens02b]</A>.
</P><P>

<A NAME="Unit Testing with JML"></A>
<HR SIZE="6">
<A NAME="SEC9"></A>
<H3> 1.4.4 Unit Testing with JML </H3>
<!--docid::SEC9::-->
<P>

<A NAME="IDX201"></A>
<A NAME="IDX202"></A>
<A NAME="IDX203"></A>
The run time assertion checker is also integrated with a tool, <CODE>jmlunit</CODE>
that can write out a JUnit [Beck-Gamma98]
test oracle class for given Java files.
For example, to generate the classes
<CODE>UnboundedStack_JML_Test</CODE> and 
<CODE>UnboundedStack_JML_TestData</CODE>
from <CODE>UnboundedStack</CODE>,
one would execute the following.
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>   jmlunit UnboundedStack.java
</pre></td></tr></table></P><P>

<A NAME="IDX204"></A>
The file <TT>`UnboundedStack_JML_Test.java'</TT> will then contain code
for an abstract class to drive the tests.  This class uses the runtime
assertion checker to decide test success or failure. (Tests are only
as good as the quality of the specifications; hence the specifications
must be reasonably complete to permit reasonably complete testing.)
</P><P>

<A NAME="IDX205"></A>
<A NAME="IDX206"></A>
The file <TT>`UnboundedStack_JML_TestData.java'</TT> will contain code for
the superclass of <CODE>UnboundedStack_JML_Test</CODE>
that can be used to fill in test data for such testing.  You need to fill in
the test data in the code for this subclass, as described in the
comments.  The file <TT>`UnboundedStack_JML_TestData.java'</TT> is
produced automatically the first time you run <CODE>jmlunit</CODE> as
described above. However, subsequent runs of <CODE>jmlunit</CODE> never
overwrite or change an <TT>`_JML_TestData.java'</TT> file such as this if
it exists.  Hence it is safe to edit the file to add test data (and
even additional test methods if you wish).
</P><P>

To run the test use the script <CODE>jml-junit</CODE>, as in the following example.
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>   jml-junit org.jmlspecs.samples.stacks.UnboundedStack_JML_TestData
</pre></td></tr></table></P><P>

More details on invoking these tools can be found in their manual
pages which ship with the JML release.
More discussion on this integration of JML and JUnit are explained
in the ECOOP 2002 paper by Cheon and Leavens <A HREF="prelimdesign_6.html#BIB14">[Cheon-Leavens02]</A>.
</P><P>

<A NAME="IDX207"></A>
JML also provides a tool, <CODE>jtest</CODE>, that combines both <CODE>jmlc</CODE>
and <CODE>jmlunit</CODE>.
The <CODE>jtest</CODE> tool both compiles a class
with run-time assertion checks enabled using <CODE>jmlc</CODE>,
and also generates the test oracle and test data classes, using
<CODE>jmlunit</CODE>.
</P><P>

<A NAME="Outline"></A>
<HR SIZE="6">
<A NAME="SEC10"></A>
<H2> 1.5 Outline </H2>
<!--docid::SEC10::-->
<P>

In the next sections we describe more about JML
and its semantics.
See section <A HREF="prelimdesign_2.html#SEC11">2. Class and Interface Specifications</A>,
for examples that show how Java classes and interfaces are specified;
this section also briefly describes the semantics of subtyping and refinement.
See section <A HREF="prelimdesign_3.html#SEC49">3. Extensions to Java Expressions</A>,
for a description of the expressions
that can be used in specifications.
See section <A HREF="prelimdesign_4.html#SEC52">4. Conclusions</A>, for conclusions from our
preliminary design effort.
See the <CITE>JML Reference Manual</CITE> <A HREF="prelimdesign_6.html#BIB40">[Leavens-etal-JMLRef]</A>
for details on the syntax of JML.
</P><P>

<A NAME="Class and Interface Specifications"></A>
<HR SIZE="6">
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="prelimdesign_1.html#SEC5"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="prelimdesign_2.html#SEC11"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="prelimdesign.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="prelimdesign_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="prelimdesign_7.html#SEC56">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="prelimdesign_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<BR>  
<FONT SIZE="-1">
This document was generated
by <I>Gary Leavens</I> on <I>January, 9  2008</I>
using <A HREF="http://www.mathematik.uni-kl.de/~obachman/Texi2html
"><I>texi2html</I></A>

</BODY>
</HTML>
