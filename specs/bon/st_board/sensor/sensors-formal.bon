static_diagram STATIC_DIAGRAM
component
  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  -- TYPE_CLUSTER cluster classes
  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  
  cluster TYPE_CLUSTER

    class THERMISTOR_SENSOR_TYPE 
    indexing
    	about:        "This class represents an implementation of sensor types.";
  		title:        "SensorType";
  		author:       "Dragan Stosic";
  		copyright:    "none";
  		organisation: "School of Computer Science and Informatics, UCD";
  		date:         "2009/07/05";
  		version:      "Revision: 1.00";
    feature{NONE}
      make
      
    feature
      -- The enum values, which are stored in an array, is constant and that 
      -- all fields declared as that type are of that type.
      array: SEQUENCE[INTEGER]
        ensure
          Result = old array;
        end
      						-- The Negative temperature coefficient thermistor.
      						-- For NTCs, the resistance decreases with temperature.
      NTC: INTEGER
        ensure
          Result = 0;
        end
      
                            -- The Positive temperature coefficient thermistor. 
	  						-- For PTCs, the resistance increases with temperature.
      PTC: INTEGER
        ensure
          Result = 1;
        end
    
    feature{THERMISTOR_SENSOR_TYPE}
    
      legal_ThermSensorType: BOOLEAN -> e: INTEGER
        require
          e /= Void;
        ensure
          Result /= Void;
          (e = array.item(0) or e = array.item(1)) <-> Result;
        end
    
    invariant
      legal_ThermSensorType(NTC);
      legal_ThermSensorType(PTC);
    end
    class ULTRASONIC_SENSOR_TYPE 
    indexing
    	about:        "This class represents ultrasonic sensor type.";
  		title:        "UltrasonicSensorType";
  		author:       "Dragan Stosic";
  		copyright:    "none";
  		organisation: "School of Computer Science and Informatics, UCD";
  		date:         "2009/07/05";
  		version:      "Revision: 1.00";
    feature{NONE}
      make
    feature
      -- The enum values, which are stored in an array, is constant and that 
      -- all fields declared as that type are of that type.
      array: SEQUENCE[INTEGER]
        ensure
          Result = old array;
        end
        
      PROX: INTEGER			--The Proximity ultrasonic sensor.
        ensure
          Result = 0;
        end
      RANG: INTEGER			--The Ranging ultrasonic sensor.
        ensure
          Result = 1;
        end
        
    feature{ULTRASONIC_SENSOR_TYPE}
      legal_UltraSensorType: BOOLEAN -> e: INTEGER
        require
          e /= Void;
        ensure
          Result /= Void;
          (e = array.item(0) or e = array.item(1)) <-> Result;
        end

    invariant
      legal_UltraSensorType(PROX);
      legal_UltraSensorType(RANG);
      end
      
   class SOUND_SENSOR_TYPE 
    indexing
    	about:        "This class represents microphone sensor type.";
  		title:        "SoundSensorType";
  		author:       "Dragan Stosic";
  		copyright:    "none";
  		organisation: "School of Computer Science and Informatics, UCD";
  		date:         "2009/07/05";
  		version:      "Revision: 1.00";
    feature{NONE}
      make
    -- The enum values, which are stored in an array, is constant and that 
    -- all fields declared as that type are of that type.
    feature
       array: SEQUENCE[INTEGER]
        ensure
          Result = old array;
        end
      CCEM: INTEGER		--Condenser, capacitor or electrostatic microphone sensor.
        ensure
          Result = 8;
        end
      CMS: INTEGER		--The Carbon microphone sensor.
        ensure
          Result = 1;
        end
      DMS: INTEGER		--The Dynamic microphone sensor.
        ensure
          Result = 0;
        end
      FOS: INTEGER		--The Fiber optical microphone sensor.    
        ensure
          Result = 3;
        end
      LMS: INTEGER		--The Laser microphone sensor.
        ensure
          Result = 4;
        end
      LQMS: INTEGER		--The Liquid microphone sensor.
        ensure
          Result = 5;
        end
      MEMS: INTEGER		--The MEMS microphone sensor.
        ensure
          Result = 6;
        end
      PMS: INTEGER		--The Piezoelectric microphone sensor.
        ensure
          Result = 2;
        end
      SMS: INTEGER 		--The Speaker as microphone sensor.
        ensure
          Result = 7;
        end
    feature{SOUND_SENSOR_TYPE}
      legal_SoundSensorType: BOOLEAN -> e: INTEGER
        require
          e /= Void;
        ensure
          Result /= Void;
          (e = array.item(0) or e = array.item(1) or 
           e = array.item(2) or e = array.item(3) or 
           e = array.item(4) or e = array.item(5) or 
           e = array.item(6) or e = array.item(7) or 
           e = array.item(8)) <-> Result;
        end

    invariant
      legal_SoundSensorType(DMS);
      legal_SoundSensorType(CMS);
      legal_SoundSensorType(PMS);
      legal_SoundSensorType(FOS);
      legal_SoundSensorType(LMS);
      legal_SoundSensorType(LQMS);
      legal_SoundSensorType(MEMS);
      legal_SoundSensorType(SMS);
      legal_SoundSensorType(CCEM);
     end
   
   class SENSOR_TYPE 
    indexing
    	about:        "This class represents an implementation of sensor types.";
  		title:        "SensorType";
  		author:       "Dragan Stosic";
  		copyright:    "none";
  		organisation: "School of Computer Science and Informatics, UCD";
  		date:         "2009/07/05";
  		version:      "Revision: 1.00";
    feature{NONE}
      make
    feature
    -- The enum values, which are stored in an array, is constant and that 
    -- all fields declared as that type are of that type.
       array: SEQUENCE[INTEGER]
        ensure
          Result = old array;
        end
      ACCEL_X: INTEGER		-- Accelerometer sensor - X axe orientation.
        ensure
          Result = 5;
        end
      ACCEL_Y: INTEGER		-- Accelerometer sensor - Y axe orientation.
        ensure
          Result = 6;
        end
      ACCEL_Z: INTEGER		-- Accelerometer sensor - Z axe orientation.
        ensure
          Result = 7;
        end
      
      LIGHT: INTEGER		-- The Light sensor type.
        ensure
          Result = 1;
        end
      PRESS: INTEGER		-- The Pressure sensor type.
        ensure
          Result = 2;
        end
      SOUND: INTEGER		-- The Sound sensor type.
        ensure
          Result = 3;
        end
      THERM: INTEGER		-- The Thermistor sensor type.
        ensure
          Result = 0;
        end
      ULTRA: INTEGER		-- The Ultrasonic sensor type.
        ensure
          Result = 4;
        end
    feature{SENSOR_TYPE}
      legal_SensorType: BOOLEAN -> e: INTEGER
        require
          e /= Void;
        ensure
          Result /= Void;
          (e = array.item(0) or e = array.item(1) or 
           e = array.item(2) or e = array.item(3) or 
           e = array.item(4) or e = array.item(5) or 
           e = array.item(6) or e = array.item(7)) <-> Result;
        end

    invariant
      legal_SensorType(THERM);
      legal_SensorType(LIGHT);
      legal_SensorType(PRESS);
      legal_SensorType(SOUND);
      legal_SensorType(ULTRA);
      legal_SensorType(ACCEL_X);
      legal_SensorType(ACCEL_Y);
      legal_SensorType(ACCEL_Z);
    end
    
    class PRESSURE_SENSOR_TYPE 
    indexing
    	about:        "This class represents pressure sensor type.";
  		title:        "PressureSensorType";
  		author:       "Dragan Stosic";
  		copyright:    "none";
  		organisation: "School of Computer Science and Informatics, UCD";
  		date:         "2009/07/05";
  		version:      "Revision: 1.00";
    feature{NONE}
      make
      
    feature
    -- The enum values, which are stored in an array, is constant and that 
    -- all fields declared as that type are of that type.
     array: SEQUENCE[INTEGER]
        ensure
          Result = old array;
        end
      
      APS: INTEGER		-- The Absolute pressure sensor.
        ensure
          Result = 0;
        end
      
      DPS: INTEGER		--The Differential pressure sensor.
        ensure
          Result = 3;
        end
      GPS: INTEGER		--The Gauge pressure sensor.
        ensure
          Result = 1;
        end
      SPS: INTEGER		--The Sealed pressure sensor.
        ensure
          Result = 4;
        end
      VPS: INTEGER		--The Vacuum pressure sensor.
        ensure
          Result = 2;
        end
    feature{PRESSURE_SENSOR_TYPE}
      legal_PressSensorType: BOOLEAN -> e: INTEGER
        require
          e /= Void;
        ensure
          Result /= Void;
          (e = array.item(0) or e = array.item(1) or 
           e = array.item(2) or e = array.item(3) or 
           e = array.item(4)) <-> Result;
        end
   
    invariant
      legal_PressSensorType(APS);
      legal_PressSensorType(GPS);
      legal_PressSensorType(VPS);
      legal_PressSensorType(DPS);
      legal_PressSensorType(SPS);
      end
      
    class LIGHT_SENSOR_TYPE 
     indexing
    	about:        "This class represents light sensor type.";
  		title:        "LightSensorType";
  		author:       "Dragan Stosic";
  		copyright:    "none";
  		organisation: "School of Computer Science and Informatics, UCD";
  		date:         "2009/07/05";
  		version:      "Revision: 1.00";
  	feature{NONE}
      make
    
    feature
     -- The enum values, which are stored in an array, is constant and that 
    -- all fields declared as that type are of that type.
     array: SEQUENCE[INTEGER]
        ensure
          Result = old array;
        end
      
      PCC: INTEGER		--The Photo-conductive Cells light sensor.
        ensure
          Result = 1;
        end
      
      PEC: INTEGER		--The Photo-emissive Cells light sensor.
        ensure
          Result = 0;
        end
      
      PJU: INTEGER		--The Photo-junction light sensor.
        ensure
          Result = 3;
        end
      
      PVC: INTEGER		--The Photo-voltaic Cells light sensor.
        ensure
          Result = 2;
        end
    
    feature{LIGHT_SENSOR_TYPE}
      legal_LightSensorType: BOOLEAN -> e: INTEGER
        require
          e /= Void;
        ensure
          Result /= Void;
          (e = array.item(0) or e = array.item(1) or 
           e = array.item(2) or e = array.item(3)) <-> Result;
        end

    invariant
      legal_LightSensorType(PEC);
      legal_LightSensorType(PCC);
      legal_LightSensorType(PVC);
      legal_LightSensorType(PJU);
    end
       class ACCELEROMETER_SENSOR_TYPE 
    indexing
    	about:        "This class represents accelerometer sensor type.";
  		title:        "AccelerometerSensorType";
  		author:       "Dragan Stosic";
  		copyright:    "none";
  		organisation: "School of Computer Science and Informatics, UCD";
  		date:         "2009/07/05";
  		version:      "Revision: 1.00";
    feature{NONE}
      make
    feature
     -- The enum values, which are stored in an array, is constant and that 
    -- all fields declared as that type are of that type.    
      array: SEQUENCE[INTEGER]
        ensure
          Result = old array;
        end
        
      MEMS: INTEGER		--The Surface Micromachined Capacitive.
        ensure
          Result = 2;
        end
      
      PFPS: INTEGER		--The Piezo-film or piezoelectric sensor.
        ensure
          Result = 0;
        end
      
      SMA: INTEGER		--The Shear Mode Accelerometer.
        ensure
          Result = 1;
        end
      
      TCMOS: INTEGER	--Thermal (submicrometre CMOS process).
        ensure
          Result = 3;
        end
    feature{ACCELEROMETER_SENSOR_TYPE}
      legal_AccSensorType: BOOLEAN -> e: INTEGER
        require
          e /= Void;
        ensure
          Result /= Void;
          (e = array.item(0) or e = array.item(1) or 
           e = array.item(2) or e = array.item(3)) <-> Result;
        end

    invariant
      legal_AccSensorType(PFPS);
      legal_AccSensorType(SMA);
      legal_AccSensorType(MEMS);
      legal_AccSensorType(TCMOS)
      end
  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  -- SENSOR_CLUSTER cluster classes
  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~       
    cluster SENSOR_CLUSTER

    deferred class ISENSOR interfaced 
    indexing
    	about:        "This deffered class represents an abstract sensor.";
  		title:        "ISensor";
  		author:       "Dragan Stosic";
  		copyright:    "none";
  		organisation: "School of Computer Science and Informatics, UCD";
  		date:         "2009/07/05";
  		version:      "Revision: 1.00";
    feature

      mod_enabled: BOOLEAN      -- @.Model @.Instance boolean mod_enabled;
        ensure
          Result /= Void;
        end
      mod_max: INTEGER 			-- @.Model @.Instance int mod_max;
        ensure
          Result /= Void;
        end
      mod_mesure: JMLDATA_GROUP -- @.Model @.Instance JMLDataGroup mod_mesure;
        ensure
          Result /= Void;
        end
      mod_min: INTEGER			-- @.Model @.Instance int mod_min;
        ensure
          Result /= Void;
        end
      mod_type: INTEGER			-- @.Model @.Instance int mod_type;
        ensure
          Result /= Void;
        end
      mod_value: INTEGER		-- @.Model @.Instance int mod_value;
        ensure
          Result /= Void;
        end
    
     feature{ISENSOR}
      
      deferred getMax: INTEGER --What is the maximal value for this component ?
        require
          isEnabled;
        ensure
          Result /= Void;
          Result = mod_max;
        end
      
      deferred getMin: INTEGER --What is the minimal value for this component ?
        require
          isEnabled;
        ensure
          Result /= Void;
          Result = mod_min;
        end
      deferred getSensorType: INTEGER --Which type of sensor are you?
        ensure
          Result /= Void;
          Result = mod_type;
        end
        
      deferred getValue: INTEGER --What is the measured value for this component ?
        require
          isEnabled;
        ensure
          Result /= Void;
          Result = mod_value;
        end
      
      deferred isEnabled: BOOLEAN --Are you enabled ?
        ensure
          Result /= Void;
        end
      
      deferred measure --Measure current value.If sensor is not available notify client class.
        require
          isEnabled;
        ensure
          delta {mod_mesure, mod_value};
          mod_min <= mod_value;
          mod_value <= mod_max;
        end
      
      deferred setEnable		--Turn off / on this component.
        -> theFlag: BOOLEAN
        require
          theFlag /= Void;
        ensure
          delta mod_enabled;
          mod_enabled = theFlag;
        end
     
     invariant					--Measured value must to be between minimum and maximum value.
      mod_min <= mod_value;
      mod_value <= mod_max;
    end
    
    class MEASUREMENT_UNIT 
    indexing
      about: "This class represents typesafe implementation of measurement units.";
      title:        "MeasurementUnit";
  	  author:       "Dragan Stosic";
  	  copyright:    "none";
  	  organisation: "School of Computer Science and Informatics, UCD";
  	  date:         "2009/07/05";
  	  version:      "Revision: 1.00";
	feature{NONE}
      make    
    
    feature
    -- The enum values, which are stored in an array, is constant and that 
    -- all fields declared as that type are of that type.   
       array: SEQUENCE[INTEGER]
        ensure
          Result = old array;
        end
        
      AMPER: INTEGER	--A -Amper (currency).
        ensure
          Result = 0;
        end
      
      CELSIUS: INTEGER	--C - Temperature - Celsius.
        ensure
          Result = 5;
        end
      
      DECIBEL: INTEGER	--dB - Decibel.
        ensure
          Result = 4;
        end
      
      HERTZ: INTEGER	--Hz - Hertz (frequency).
        ensure
          Result = 3;
        end
      
      LUX: INTEGER		--lux - light - lux.
        ensure
          Result = 7;
        end
      
      MVOLT: INTEGER	--mV -mili Voltage (voltage).
        ensure
          Result = 2;
        end
      
      PASCAL: INTEGER	--pa - pressure - Pascal.
        ensure
          Result = 6;
        end
      
      VOLT: INTEGER		--V -Voltage (voltage).
        ensure
          Result = 1;
        end
        
    feature{MEASUREMENT_UNIT}
      legal_unit: BOOLEAN -> e: INTEGER
        require
          e /= Void;
        ensure
          Result /= Void;
          (e = array.item(0) or e = array.item(1) or 
           e = array.item(2) or e = array.item(3) or 
           e = array.item(4) or e = array.item(5) or 
           e = array.item(6) or e = array.item(7)) <-> Result;
        end

    invariant
      legal_unit(AMPER);
      legal_unit(VOLT);
      legal_unit(MVOLT);
      legal_unit(HERTZ);
      legal_unit(DECIBEL);
      legal_unit(CELSIUS);
      legal_unit(PASCAL);
      legal_unit(LUX);
      end
      
     effective class MISSING_SENSOR_EXCEPTION  
     indexing
      about: "Class implementation of sensor.MissingSensorException. Exception is used during measurement operations.";
      title:        "MeasurementUnit";
  	  author:       "Dragan Stosic";
  	  copyright:    "none";
  	  organisation: "School of Computer Science and Informatics, UCD";
  	  date:         "2009/07/05";
  	  version:      "Revision: 1.00";
  	  
     feature
      make
      make0 -> message: STRING
        require
          message /= Void;
        end
        
      make1 -> cause: THROWABLE
        require
          cause /= Void;
        end
        
      make2 -> message: STRING -> cause: THROWABLE
        require
          message /= Void;
          cause /= Void;
        end
        
    feature{MISSING_SENSOR_EXCEPTION}
      serialVersionUID: INTEGER
    end
    
    effective class ULTRASONIC_SENSOR 
    indexing
      about: "This class represents Ultrasonic sensor.";
      title:        "UltrasonicSensor";
  	  author:       "Dragan Stosic";
  	  copyright:    "none";
  	  organisation: "School of Computer Science and Informatics, UCD";
  	  date:         "2009/07/05";
  	  version:      "Revision: 1.00";
  	  
  	  inherit ISENSOR
    
    feature{NONE}
      index: INTEGER
        ensure
          Result /= Void;
        end
      MAX: INTEGER
        ensure
          Result = "-43";
        end
      MIN: INTEGER
        ensure
          Result = "-51";
        end
      setUltraSound -> index: INTEGER
        require
          index /= Void;
          index >= 0;
          index < mod_set.count;
        ensure
          delta mod_value;
          mod_min <= mod_value;
          mod_value <= mod_max;
          mod_max = -43;
          mod_min = -51;
          mod_type = SensorType.ULTRA;
          a_type = UltrasonicSensorType.PROX;
          a_unit = MeasurementUnit.DECIBEL;
        end
        
    feature
      make -> arr: SEQUENCE[INTEGER]
        require
          arr /= Void;
        ensure
          delta {mod_enabled, mod_set};
          mod_enabled = true;
          -- ((\forall  int i,;0 <= i && i < arr.length;arr[i] == a_set[i]));
          mod_max = -43;
          mod_min = -51;
          mod_type = SensorType.ULTRA;
          a_type = UltrasonicSensorType.PROX;
          a_unit = MeasurementUnit.DECIBEL;
        end
        
      a_sensType: INTEGER
        ensure
          Result = 4;
        end
        
      a_set: SEQUENCE[INTEGER]
        ensure
          Result /= Void;
        end
        
      a_type: INTEGER
        ensure
          Result = 0;
        end
      
      a_unit: INTEGER
        ensure
          Result = 4;
        end
      
      enabled: BOOLEAN
        ensure
          Result /= Void;
        end
      
      getType: INTEGER
        require
          isEnabled;
        ensure
          Result /= Void;
          Result = UltrasonicSensorType.PROX;
        end
      
      getUnit: INTEGER
        require
          isEnabled;
        ensure
          Result /= Void;
          Result = MeasurementUnit.DECIBEL;
        end
      
      mod_set: SEQUENCE[INTEGER]
        ensure
          Result /= Void;
        end
      
      value: INTEGER
        ensure
          Result /= Void;
        end
      
      measure
        ensure
          mod_max = -43;
          mod_min = -51;
          mod_type = SensorType.ULTRA;
          a_type = UltrasonicSensorType.PROX;
          a_unit = MeasurementUnit.DECIBEL;
        end
      
      setEnable -> theFlag: BOOLEAN
        require
          theFlag /= Void;
        ensure
          mod_max = -43;
          mod_min = -51;
          mod_type = SensorType.ULTRA;
          a_type = UltrasonicSensorType.PROX;
          a_unit = MeasurementUnit.DECIBEL;
        end
      
      getMax: INTEGER
        ensure
          Result /= Void;
        end
      
      getMin: INTEGER
        ensure
          Result /= Void;
        end
      
      getSensorType: INTEGER
        ensure
          Result /= Void;
          Result = SensorType.ULTRA;
        end
   end
   
   effective class LIGHT_SENSOR 
    indexing
      about: "This class represents Light sensor.";
      title:        "LightSensor";
  	  author:       "Dragan Stosic";
  	  copyright:    "none";
  	  organisation: "School of Computer Science and Informatics, UCD";
  	  date:         "2009/07/05";
  	  version:      "Revision: 1.00";
  	  
  	 inherit ISENSOR
  	      
    feature{NONE}
      index: INTEGER
        ensure
          Result /= Void;
        end
      MAX: INTEGER
        ensure
          Result = 1000;
        end
      MIN: INTEGER
        ensure
          Result = 0;
        end
      setLight
        -> index: INTEGER
        require
          index /= Void;
          index >= 0;
          index < mod_set.count;
        ensure
          delta mod_value;
          mod_min <= mod_value;
          mod_value <= mod_max;
          mod_max = 1000;
          mod_min = 0;
          mod_type = SensorType.LIGHT;
          a_type = LightSensorType.PEC;
          a_unit = MeasurementUnit.LUX;
        end
        
    feature
      make -> arr: SEQUENCE[INTEGER]
        require
          arr /= Void;
        ensure
          delta {mod_enabled, mod_set};
          mod_enabled = true;
          -- ((\forall  int i,;0 <= i && i < arr.length;arr[i] == a_set[i]));
          mod_max = 1000;
          mod_min = 0;
          mod_type = SensorType.LIGHT;
          a_type = LightSensorType.PEC;
          a_unit = MeasurementUnit.LUX;
        end
      
      a_sensType: INTEGER
        ensure
          Result = 1;
        end
      
      a_set: SEQUENCE[INTEGER]
        ensure
          Result /= Void;
        end
      
      a_type: INTEGER
        ensure
          Result = 0;
        end
      
      a_unit: INTEGER
        ensure
          Result = 7;
        end
      
      enabled: BOOLEAN
        ensure
          Result /= Void;
        end
      
      getType: INTEGER
        require
          isEnabled;
        ensure
          Result /= Void;
          Result = LightSensorType.PEC;
        end
      
      getUnit: INTEGER
        require
          isEnabled;
        ensure
          Result /= Void;
          Result = MeasurementUnit.LUX;
        end
      
      mod_set: SEQUENCE[INTEGER]
        ensure
          Result /= Void;
        end
      
      value: INTEGER
        ensure
          Result /= Void;
        end
      measure
        ensure
          mod_max = 1000;
          mod_min = 0;
          mod_type = SensorType.LIGHT;
          a_type = LightSensorType.PEC;
          a_unit = MeasurementUnit.LUX;
        end
      
      setEnable -> theFlag: BOOLEAN
        require
          theFlag /= Void;
        ensure
          mod_max = 1000;
          mod_min = 0;
          mod_type = SensorType.LIGHT;
          a_type = LightSensorType.PEC;
          a_unit = MeasurementUnit.LUX;
        end
      
      getMax: INTEGER
        ensure
          Result /= Void;
        end
      
      getMin: INTEGER
        ensure
          Result /= Void;
        end
      
      getSensorType: INTEGER
        ensure
          Result /= Void;
          Result = SensorType.LIGHT;
        end
    end
    
   effective class PRESSURE_SENSOR
       indexing
      about: "This class represents pressure sensor.";
      title:        "PressureSensor";
  	  author:       "Dragan Stosic";
  	  copyright:    "none";
  	  organisation: "School of Computer Science and Informatics, UCD";
  	  date:         "2009/07/05";
  	  version:      "Revision: 1.00";
  	 
  	 inherit ISENSOR
  	  
  	  
    feature{NONE}
      index: INTEGER
        ensure
          Result /= Void;
        end
      MAX: INTEGER
        ensure
          Result = 115000;
        end
      MIN: INTEGER
        ensure
          Result = 15000;
        end
      setPressure -> index: INTEGER
        require
          index /= Void;
          index >= 0;
          index < mod_set.count;
        ensure
          delta mod_value;
          mod_min <= mod_value;
          mod_value <= mod_max;
          mod_max = 115000;
          mod_min = 15000;
          mod_type = SensorType.PRESS;
          a_type = PressureSensorType.APS;
          a_unit = MeasurementUnit.PASCAL;
        end
    
    feature
      make -> arr: SEQUENCE[INTEGER]
        require
          arr /= Void;
        ensure
          delta {mod_enabled, mod_set};
          mod_enabled = true;
          -- ((\forall  int i,;0 <= i && i < arr.length;arr[i] == a_set[i]));
          mod_max = 115000;
          mod_min = 15000;
          mod_type = SensorType.PRESS;
          a_type = PressureSensorType.APS;
          a_unit = MeasurementUnit.PASCAL;
        end
      
      a_sensType: INTEGER
        ensure
          Result = 2;
        end
      
      a_set: SEQUENCE[INTEGER]
        ensure
          Result /= Void;
        end
      
      a_type: INTEGER
        ensure
          Result = 0;
        end
      
      a_unit: INTEGER
        ensure
          Result = 6;
        end
      
      enabled: BOOLEAN
        ensure
          Result /= Void;
        end
      
      getType: INTEGER
        require
          isEnabled;
        ensure
          Result /= Void;
          Result = PressureSensorType.APS;
        end
      
      getUnit: INTEGER
        require
          isEnabled;
        ensure
          Result /= Void;
          Result = MeasurementUnit.PASCAL;
        end
      
      mod_set: SEQUENCE[INTEGER]
        ensure
          Result /= Void;
        end
      
      value: INTEGER
        ensure
          Result /= Void;
        end
      
      measure
        ensure
          mod_max = 115000;
          mod_min = 15000;
          mod_type = SensorType.PRESS;
          a_type = PressureSensorType.APS;
          a_unit = MeasurementUnit.PASCAL;
        end
      
      setEnable -> theFlag: BOOLEAN
        require
          theFlag /= Void;
        ensure
          mod_max = 115000;
          mod_min = 15000;
          mod_type = SensorType.PRESS;
          a_type = PressureSensorType.APS;
          a_unit = MeasurementUnit.PASCAL;
        end
      
      getMax: INTEGER
        ensure
          Result /= Void;
        end
      
      getMin: INTEGER
        ensure
          Result /= Void;
        end
      
      getSensorType: INTEGER
        ensure
          Result /= Void;
          Result = SensorType.PRESS;
        end
      end
      
    effective class SOUND_SENSOR 
      indexing
      about: "This class represents sound sensor.";
      title:        "SoundSensor";
  	  author:       "Dragan Stosic";
  	  copyright:    "none";
  	  organisation: "School of Computer Science and Informatics, UCD";
  	  date:         "2009/07/05";
  	  version:      "Revision: 1.00";
  	  
  	  inherit ISENSOR
  	  
    feature{NONE}
      index: INTEGER
        ensure
          Result /= Void;
        end
      MAX: INTEGER
        ensure
          Result = "-31";
        end
      MIN: INTEGER
        ensure
          Result = "-39";
        end
      setSound
        -> index: INTEGER
        require
          index /= Void;
          index >= 0;
          index < mod_set.count;
        ensure
          delta mod_value;
          mod_min <= mod_value;
          mod_value <= mod_max;
          mod_max = -31;
          mod_min = -39;
          mod_type = SensorType.SOUND;
          a_type = SoundSensorType.DMS;
          a_unit = MeasurementUnit.DECIBEL;
        end
    feature
      make -> arr: SEQUENCE[INTEGER]
        require
          arr /= Void;
        ensure
          delta {mod_enabled, mod_set};
          mod_enabled = true;
          -- ((\forall  int i,;0 <= i && i < arr.length;arr[i] == a_set[i]));
          mod_max = -31;
          mod_min = -39;
          mod_type = SensorType.SOUND;
          a_type = SoundSensorType.DMS;
          a_unit = MeasurementUnit.DECIBEL;
        end
        
      a_sensType: INTEGER
        ensure
          Result = 3;
        end
      
      a_set: SEQUENCE[INTEGER]
        ensure
          Result /= Void;
        end
      
      a_type: INTEGER
        ensure
          Result = 0;
        end
      
      a_unit: INTEGER
        ensure
          Result = 4;
        end
      
      enabled: BOOLEAN
        ensure
          Result /= Void;
        end
      
      getType: INTEGER
        require
          isEnabled;
        ensure
          Result /= Void;
          Result = SoundSensorType.DMS;
        end
      
      getUnit: INTEGER
        require
          isEnabled;
        ensure
          Result /= Void;
          Result = MeasurementUnit.DECIBEL;
        end
      
      mod_set: SEQUENCE[INTEGER]
        ensure
          Result /= Void;
        end
      
      value: INTEGER
        ensure
          Result /= Void;
        end
      
      measure
        ensure
          mod_max = -31;
          mod_min = -39;
          mod_type = SensorType.SOUND;
          a_type = SoundSensorType.DMS;
          a_unit = MeasurementUnit.DECIBEL;
        end
      
      setEnable -> theFlag: BOOLEAN
        require
          theFlag /= Void;
        ensure
          mod_max = -31;
          mod_min = -39;
          mod_type = SensorType.SOUND;
          a_type = SoundSensorType.DMS;
          a_unit = MeasurementUnit.DECIBEL;
        end
      
      getMax: INTEGER
        ensure
          Result /= Void;
        end
      
      getMin: INTEGER
        ensure
          Result /= Void;
        end
      
      getSensorType: INTEGER
        ensure
          Result /= Void;
          Result = SensorType.SOUND;
        end
      end
   effective class THERMISTOR_SENSOR
       indexing
      about: "This class represents thermistor sensor.";
      title:        "ThermistorSensor";
  	  author:       "Dragan Stosic";
  	  copyright:    "none";
  	  organisation: "School of Computer Science and Informatics, UCD";
  	  date:         "2009/07/05";
  	  version:      "Revision: 1.00";
  	
  	inherit ISENSOR
  	
    feature{NONE}
      index: INTEGER
        ensure
          Result /= Void;
        end
      MAX: INTEGER
        ensure
          Result = 127;
        end
      MIN: INTEGER
        ensure
          Result = "-55";
        end
      setTemp
        -> index: INTEGER
        require
          index /= Void;
          index >= 0;
          index < mod_set.count;
        ensure
          delta mod_value;
          mod_min <= mod_value;
          mod_value <= mod_max;
          mod_max = 127;
          mod_min = -55;
          mod_type = SensorType.THERM;
          a_type = ThermistorSensorType.NTC;
          a_unit = MeasurementUnit.CELSIUS;
        end
    
    feature
      make -> arr: SEQUENCE[INTEGER]
        require
          arr /= Void;
        ensure
          delta {mod_enabled, mod_set};
          mod_enabled = true;
          -- ((\forall  int i,;0 <= i && i < arr.length;arr[i] == a_set[i]));
          mod_max = 127;
          mod_min = -55;
          mod_type = SensorType.THERM;
          a_type = ThermistorSensorType.NTC;
          a_unit = MeasurementUnit.CELSIUS;
        end
        
      a_sensType: INTEGER
        ensure
          Result = 0;
        end
        
      a_set: SEQUENCE[INTEGER]
        ensure
          Result /= Void;
        end
      
      a_type: INTEGER
        ensure
          Result = 0;
        end
      
      a_unit: INTEGER
        ensure
          Result = 5;
        end
      
      enabled: BOOLEAN
        ensure
          Result /= Void;
        end
      
      getType: INTEGER
        require
          isEnabled;
        ensure
          Result /= Void;
          Result = ThermistorSensorType.NTC;
        end
      
      getUnit: INTEGER
        require
          isEnabled;
        ensure
          Result /= Void;
          Result = MeasurementUnit.CELSIUS;
        end
      
      mod_set: SEQUENCE[INTEGER]
        ensure
          Result /= Void;
        end
      
      value: INTEGER
        ensure
          Result /= Void;
        end
      
      measure
        ensure
          mod_max = 127;
          mod_min = -55;
          mod_type = SensorType.THERM;
          a_type = ThermistorSensorType.NTC;
          a_unit = MeasurementUnit.CELSIUS;
        end
      
      setEnable -> theFlag: BOOLEAN
        require
          theFlag /= Void;
        ensure
          mod_max = 127;
          mod_min = -55;
          mod_type = SensorType.THERM;
          a_type = ThermistorSensorType.NTC;
          a_unit = MeasurementUnit.CELSIUS;
        end
      
      getMax: INTEGER
        ensure
          Result /= Void;
        end
      
      getMin: INTEGER
        ensure
          Result /= Void;
        end
      
      getSensorType: INTEGER
        ensure
          Result /= Void;
          Result = SensorType.THERM;
        end
      end
    
   effective class AXIS_ACCELEROMETER_SENSOR 
    indexing
      about: "An accelerometer measures the acceleration it experiences",
      		 "relative to freefall. Single model is available",
        	 "to detect magnitude and direction of the acceleration as",
        	 "a vector quantity, and can be used to sense orientation,",
             "vibration and shock.";
      title:        "AxisAccelerometerSensor";
  	  author:       "Dragan Stosic";
  	  copyright:    "none";
  	  organisation: "School of Computer Science and Informatics, UCD";
  	  date:         "2009/07/05";
  	  version:      "Revision: 1.00";
  	  
    inherit
      ISENSOR
    
    feature{NONE}
      index: INTEGER
        ensure
          Result /= Void;
        end
      MAX: INTEGER
        ensure
          Result = 15300;
        end
      MIN: INTEGER
        ensure
          Result = 14700;
        end
      setVoltage
        -> index: INTEGER
        require
          index /= Void;
          index >= 0;
          index < mod_set.count;
        ensure
          delta mod_value;
          mod_min <= mod_value;
          mod_value <= mod_max;
          mod_max = 15300;
          mod_min = 14700;
          a_unit = MeasurementUnit.MVOLT;
          a_type = AccelerometerSensorType.PFPS;
        end
      
    feature
      make -> arr: SEQUENCE[INTEGER] -> type: INTEGER
        require
          arr /= Void;
          type /= Void;
          type >= SensorType.ACCEL_X;
          type <= SensorType.ACCEL_Z;
        ensure
          delta {mod_enabled, mod_set, mod_type};
          mod_type = type;
          mod_enabled = true;
          -- ((\forall  int i,;0 <= i && i < arr.length;arr[i] == a_set[i]));
          mod_max = 15300;
          mod_min = 14700;
          a_unit = MeasurementUnit.MVOLT;
          a_type = AccelerometerSensorType.PFPS;
        end
        
      a_sensType: INTEGER
        ensure
          Result /= Void;
        end
      
      a_set: SEQUENCE[INTEGER]
        ensure
          Result /= Void;
        end
      
      a_type: INTEGER
        ensure
          Result = 0;
        end
      
      a_unit: INTEGER
        ensure
          Result = 2;
        end
      
      enabled: BOOLEAN
        ensure
          Result /= Void;
        end
      
      getType: INTEGER
        require
          isEnabled;
        ensure
          Result /= Void;
          Result = AccelerometerSensorType.PFPS;
        end
      
      getUnit: INTEGER
        require
          isEnabled;
        ensure
          Result /= Void;
          Result = MeasurementUnit.MVOLT;
        end
      
      legal_SensorType: BOOLEAN -> e: INTEGER
        require
          e /= Void;
        ensure
          Result /= Void;
          (e >= SensorType.ACCEL_X and e <= SensorType.ACCEL_Z) <-> Result;
        end
        
      mod_set: SEQUENCE[INTEGER]
        ensure
          Result /= Void;
        end
      
      value: INTEGER
        ensure
          Result /= Void;
        end
      
      measure
        ensure
          mod_max = 15300;
          mod_min = 14700;
          a_unit = MeasurementUnit.MVOLT;
          a_type = AccelerometerSensorType.PFPS;
        end
      
      setEnable -> theFlag: BOOLEAN
        require
          theFlag /= Void;
        ensure
          mod_max = 15300;
          mod_min = 14700;
          a_unit = MeasurementUnit.MVOLT;
          a_type = AccelerometerSensorType.PFPS;
        end
        
      getMax: INTEGER
        ensure
          Result /= Void;
        end
      
      getMin: INTEGER
        ensure
          Result /= Void;
        end
      
      getSensorType: INTEGER
        ensure
          Result /= Void;
          legal_SensorType(Result);
        end
    
    
    invariant
      legal_SensorType(mod_type);
    end
end