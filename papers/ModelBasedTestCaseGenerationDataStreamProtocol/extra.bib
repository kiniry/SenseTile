% This file was created with JabRef 2.6.
% Encoding: UTF-8

@BOOK{AbrahamssonMarchesiMaurer2009,
  title = {Agile Processes in Software Engineering and Extreme Programming:
	10th International Conference, {XP} 2009, Pula, Sardinia, Italy,
	May 25-29, 2009, Proceedings ... Notes in Business Information Processing)},
  publisher = {Springer},
  year = {2009},
  author = {Pekka Abrahamsson and Michele Marchesi and Frank Maurer},
  edition = {1},
  month = jun,
  isbn = {3642018521},
  owner = {delbianc},
  shorttitle = {Agile Processes in Software Engineering and Extreme Programming}
}

@INCOLLECTION{Baumeister2004,
  author = {Hubert Baumeister},
  title = {Combining Formal Specifications with Test Driven Development},
  booktitle = {Extreme Programming and Agile Methods - {XP/Agile} Universe 2004},
  year = {2004},
  pages = {1--12},
  abstract = {In the context of test driven development, tests specify the behavior
	of a program before the code that implements it, is actually written.
	In addition, they are used as main source of documentation in {XP}
	projects, together with the program code. However, tests alone describe
	the properties of a program only in terms of examples and thus are
	not sufficient to completely describe the behavior of a program.
	In contrast, formal specifications allow to generalize these example
	properties to more general properties, which leads to a more complete
	description of the behavior of a program. Specifications add another
	main artifact to {XP} in addition to the already existent ones, i.e.
	code and tests. The interaction between these three artifacts further
	improves the quality of both software and documentation. The goal
	of this paper is to show that it is possible, with appropriate tool
	support, to combine formal specifications with test driven development
	without loosing the agility of test driven development.},
  owner = {delbianc},
  url = {http://www.springerlink.com/content/72dfavktrrjwg7bb}
}

@BOOK{Beck2003,
  title = {Test-driven development: By example},
  publisher = {Addison-Wesley},
  year = {2003},
  author = {Kent Beck},
  owner = {delbianc}
}

@BOOK{Beck1999,
  title = {Extreme Programming Explained: Embrace Change},
  publisher = {Addison-Wesley},
  year = {1999},
  author = {Kent Beck},
  pages = {224},
  edition = {First},
  biburl = {http://www.bibsonomy.org/bibtex/28d2b2ef882d4d24791e6c4b9f9786594/franz},
  isbn = {0201616416},
  owner = {delbianc}
}

@BOOK{Beck2004,
  title = {Extreme Programming Explained: Embrace Change},
  publisher = {Addison-Wesley},
  year = {2004},
  author = {Kent Beck and Cynthia Andres},
  edition = {Second},
  biburl = {http://www.bibsonomy.org/bibtex/25a0de786b7be8a2452c7d596172209ee/tausendeins},
  isbn = {0321278658},
  owner = {delbianc},
  url = {http://portal.acm.org/citation.cfm?id=1076267}
}

@MISC{Beck2001,
  author = {Kent Beck and Mike Beedle and Arie van Bennekum and Alistair Cockburn
	and Ward Cunningham and Martin Fowler and James Grenning and Jim
	Highsmith and Andrew Hunt and Ron Jeffries and Jon Kern and Brian
	Marick and Robert C. Martin and Steve Mellor and Ken Schwaber and
	Jeff Sutherland and Dave Thomas},
  title = {Manifesto for Agile Software Development},
  year = {2001},
  abstract = {We are uncovering better ways of developing software by doing it and
	helping others do it.},
  biburl = {http://www.bibsonomy.org/bibtex/21f7f1e0beecc6aae5c519d0d5e9d1f26/juve},
  owner = {delbianc},
  url = {http://agilemanifesto.org/}
}

@INCOLLECTION{Berner2004,
  author = {David Berner and Syed Suhaib and Sandeep Kumar Shukla and {Jean-Pierre}
	Talpin},
  title = {{XFM:} extreme formal method for capturing formal specification into
	abstract models},
  booktitle = {Formal methods and models for system design: a system level perspective},
  publisher = {Kluwer Academic Publishers},
  year = {2004},
  pages = {331--349},
  abstract = {In this chapter we introduce an agile formal method (named {XFM)}
	based on extreme programming concepts to construct abstract models
	from a natural language specification of a complex system. Building
	formal models for verification purposes is being used in the industry
	for two different usage modes: (i) Descriptive Formal Models {(DFM)}
	are used to capture an implementation into an abstract model to submit
	to analysis by model checking tools, (ii) Prescriptive Formal Models
	{(PFM)} are used to capture natural language specifications into
	a formal model to analyze consistency of the specification and also
	as a reference model to compare a {DFM} against it. We propose {XFM}
	as a methodology to incrementally build a correct {PFM} from a natural
	language specification. We illustrate the benefits of the proposed
	methodology with the help of two examples: a control intensive traffic
	light controller, and the {DLX} pipeline. Our experiments show that
	this methodology not only constructs abstract models in sufficiently
	shorter time than the time taken in constructing ad hoc abstract
	models from implementation or specification, but also provides models
	that are constructively correct, closer to the intended specification
	and better structured.},
  isbn = {1-4020-8051-4},
  owner = {delbianc},
  url = {http://portal.acm.org/citation.cfm?id=1137972}
}

@BOOK{Binder1999,
  title = {Testing Object-Oriented Systems: Models, Patterns, and Tools},
  publisher = {Addison-Wesley},
  year = {1999},
  author = {Robert V. Binder},
  pages = {1191},
  isbn = {0-201-80938-9},
  owner = {delbianc},
  shorttitle = {Testing object-oriented systems},
  timestamp = {2009.10.12},
  url = {http://portal.acm.org/citation.cfm?id=SERIES9089.338330}
}

@ARTICLE{Black2009,
  author = {Sue Black and Paul P. Boca and Jonathan P. Bowen and Jason Gorman
	and Mike Hinchey},
  title = {Formal Versus Agile: Survival of the Fittest},
  journal = {Computer},
  year = {2009},
  volume = {42},
  pages = {37--45},
  number = {9},
  abstract = {The potential for combining agile and formal methods holds promise.
	Although it might not always be an easy partnership, it will succeed
	if it can foster a fruitful interchange of expertise between the
	two communities.},
  issn = {0018-9162},
  keywords = {agile methods, formal methods, software engineering},
  owner = {delbianc},
  shorttitle = {Formal Versus Agile}
}

@INPROCEEDINGS{Briand2006,
  author = {Lionel C. Briand and Yvan Labiche and Michal M. Sówka},
  title = {Automated, contract-based user testing of commercial-off-the-shelf
	components},
  booktitle = {Proceedings of the 28th international conference on Software engineering},
  year = {2006},
  pages = {92--101},
  address = {Shanghai, China},
  publisher = {{ACM}},
  abstract = {{Commercial-off-the-Shelf} {(COTS)} components provide a means to
	construct software (component-based) systems in reduced time and
	cost. In a {COTS} component software market there exist component
	vendors (original developers of the component) and component users
	(developers of the component-based systems). The former provide the
	component to the user without source code or design documentation,
	and as a result it is difficult for the latter to adequately test
	the component when deployed in their system. In this article we propose
	a framework that clarifies the roles and responsibilities of both
	parties so that the user can adequately test the component in a deployment
	environment and the vendor does not need to release proprietary details.
	Then, based on this framework we combine and adapt two specification-based
	testing techniques and describe (and implement) a method for the
	automated generation of adequate test sets. An evaluation of our
	approach on a case study demonstrates that it is possible to automatically
	generate cost effective test sequences and that these test sequences
	are effective at detecting complex errors.},
  doi = {10.1145/1134285.1134300},
  isbn = {1-59593-375-1},
  keywords = {adequacy criteria, component, cots, uml},
  owner = {delbianc},
  timestamp = {2009.10.12},
  url = {http://portal.acm.org/citation.cfm?id=1134285.1134300}
}

@BOOK{Broekman2002,
  title = {Testing Embedded Software},
  publisher = {{Addison-Wesley} Professional},
  year = {2002},
  author = {Bart Broekman and Edwin Notenboom},
  month = dec,
  isbn = {0321159861},
  owner = {delbianc},
  timestamp = {2009.10.12}
}

@INPROCEEDINGS{Cheon2005,
  author = {Yoonsik Cheon and Myoung Yee Kim and Ashaveena Perum},
  title = {A complete automation of unit testing for Java programs},
  booktitle = {Proceedings of the 2005 international conference on Software Engineering
	Research and Practice},
  year = {2005},
  pages = {290---295},
  annote = {rate: D
	
	useless
	
	promised approach (genetic algorithms) is not implemented proof of
	concept uses a random generator example is too simple, as usual
	
	to be cited},
  owner = {delbianc},
  timestamp = {2009.10.12},
  url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.99.6030}
}

@INCOLLECTION{Cheon2002,
  author = {Yoonsik Cheon and Gary Leavens},
  title = {A Simple and Practical Approach to Unit Testing: The {JML} and {JUnit}
	Way},
  booktitle = {{ECOOP} 2002 — {Object-Oriented} Programming},
  year = {2002},
  pages = {1789--1901},
  abstract = {Writing unit test code is labor-intensive, hence it is often not done
	as an integral part of programming. However, unit testing is a practical
	approach to increasing the correctness and quality of software; for
	example, the Extreme Programming approach relies on frequent unit
	testing.
	
	In this paper we present a new approach that makes writing unit tests
	easier. It uses a formal specification language’s runtime assertion
	checker to decide whether methods are working correctly, thus automating
	the writing of unit test oracles. These oracles can be easily combined
	with hand-written test data. Instead of writing testing code, the
	programmer writes formal specifications (e.g., pre-and postconditions).
	This makes the programmer’s task easier, because specifications are
	more concise and abstract than the equivalent test code, and hence
	more readable and maintainable. Furthermore, by using specifications
	in testing, specification errors are quickly discovered, so the specifications
	are more likely to provide useful documentation and inputs to other
	tools. We have implemented this idea using the Java Modeling Language
	{(JML)} and the {JUnit} testing framework, but the approach could
	be easily implemented with other combinations of formal specification
	languages and unit test tools.},
  owner = {delbianc},
  shorttitle = {A Simple and Practical Approach to Unit Testing},
  timestamp = {2009.10.12},
  url = {http://dx.doi.org/10.1007/3-540-47993-7_10}
}

@ARTICLE{Cheon2004,
  author = {Yoonsik Cheon and Gary T Leavens},
  title = {The {JML} and {JUnit} Way of Unit Testing and its Implementation},
  year = {2004},
  annote = {rate: {A/B}
	
	good and interesting approach useful tool idea: not as a substitute
	to hand written unit tests, but to pair them heavy environment requirements
	(jml, code instrumentation) inheritance on test suites does not favour
	contract testing too much details for the implementation part
	
	},
  owner = {delbianc},
  timestamp = {2009.10.12},
  url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.100.3930}
}

@ARTICLE{Chockler2006,
  author = {Hana Chockler and Orna Kupferman and Moshe Vardi},
  title = {Coverage metrics for formal verification},
  journal = {International Journal on Software Tools for Technology Transfer {(STTT)}},
  year = {2006},
  volume = {8},
  pages = {373--386},
  number = {4},
  abstract = {Abstract In formal verification, we verify that a system is correct
	with respect to a specification. Even when the system is proven to
	be correct, there is still a question of how complete the specification
	is and whether it really covers all the behaviors of the system.
	The challenge of making the verification process as exhaustive as
	possible is even more crucial in simulation-based verification, where
	the infeasible task of checking all input sequences is replaced by
	checking a test suite consisting of a finite subset of them. It is
	very important to measure the exhaustiveness of the test suite, and
	indeed there has been extensive research in the simulation-based
	verification community on coverage metrics, which provide such a
	measure. It turns out that no single measure can be absolute, leading
	to the development of numerous coverage metrics whose usage is determined
	by industrial verification methodologies. On the other hand, prior
	research of coverage in formal verification has focused solely on
	state-based coverage. In this paper we adapt the work done on coverage
	in simulation-based verification to the formal-verification setting
	in order to obtain new coverage metrics. Thus, for each of the metrics
	used in simulation-based verification, we present a corresponding
	metric that is suitable for the setting of formal verification and
	describe an algorithmic way to check it.},
  doi = {10.1007/s10009-004-0175-4},
  owner = {delbianc},
  timestamp = {2009.10.12},
  url = {http://dx.doi.org/10.1007/s10009-004-0175-4}
}

@BOOK{Cockburn2004,
  title = {Crystal Clear: A Human-Powered Methodology for Small Teams},
  publisher = {Addison-Wesley},
  year = {2004},
  author = {Alistair Cockburn},
  isbn = {0201699478},
  owner = {delbianc}
}

@INPROCEEDINGS{Eleftherakis2003,
  author = {G. Eleftherakis and A. J Cowling},
  title = {An Agile Formal Development Methodology},
  booktitle = {1st South Eastern European workshop on Formal Methods {(SEEFM} 03},
  year = {2003},
  pages = {36–47},
  owner = {delbianc}
}

@BOOK{Fowler1999,
  title = {Refactoring: Improving the Design of Existing Code},
  publisher = {Addison Wesley},
  year = {1999},
  author = {Martin Fowler and Kent Beck and John Brant and William Opdyke and
	Don Roberts},
  month = {June},
  biburl = {http://www.bibsonomy.org/bibtex/25ccb08759748d7a9ac1a207aca192af7/franz},
  isbn = {0201485672},
  owner = {delbianc}
}

@BOOK{Glass2002,
  title = {Facts and Fallacies of Software Engineering},
  publisher = {Addison-Wesley},
  year = {2002},
  author = {Robert L. Glass},
  month = {October},
  biburl = {http://www.bibsonomy.org/bibtex/22f2067241c4ef99d9a974a0601482f70/neilernst},
  citeulike-article-id = {385770},
  isbn = {0321117425},
  owner = {delbianc},
  url = {http://www.amazon.fr/exec/obidos/ASIN/0321117425/citeulike04-21}
}

@ARTICLE{Herranz2003a,
  author = {Angel Herranz and Juan Jose {Moreno-Navarro}},
  title = {Formal Agility. How much of each?},
  year = {2003},
  abstract = {Agile Processes and Formal Methods {(FM),} water and oil, impossible
	mixture? Yes at first sight. Nevertheless, being formal methods weight
	processes and being agile processes informal approaches to software
	development, it is worth to study how much formal can be an agile
	process like Extreme Programming {(XP)} and how much agile can be
	a formal method. On our view, some {XP} practices are suitable for
	a formal approach.},
  owner = {delbianc},
  url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.59.9007}
}

@INCOLLECTION{Herranz2003b,
  author = {Ángel Herranz and Juan {Moreno-Navarro}},
  title = {Formal Extreme (and Extremely Formal) Programming},
  booktitle = {Extreme Programming and Agile Processes in Software Engineering},
  year = {2003},
  pages = {1012},
  abstract = {This paper is an exploratory work were the authors study how the technology
	of Formal Methods {(FM)} can interact with agile process in general
	and with Extreme Programming {(XP)} in particular. Our thesis is
	that most of {XP} practices (pair programming, daily build, the simplest
	design or the metaphor) are technology independent and therefore
	can be used in {FM} based developments. Additionally, other essential
	pieces like test first, incremental development and refactoring can
	be improved by using {FM.} In the paper we explore in a certain detail
	those pieces: when you write a formal specification you are saying
	what your code must do, when you write a test you are doing the same
	so the idea is to use formal specifications as tests. Incremental
	development is quite similar to the refinement process in {FM:} specifications
	evolve to code maintaining previous functionality. Finally {FM} can
	help to remove redundancy, eliminate unused functionality and transform
	obsolete designs into new ones, and this is refactoring.},
  owner = {delbianc},
  url = {http://dx.doi.org/10.1007/3-540-44870-5_12}
}

@INPROCEEDINGS{Hoffman2001,
  author = {A. Hoffman and T. Kogel and H. Meyr},
  title = {A framework for fast hardware-software co-simulation},
  booktitle = {Proceedings of the conference on Design, automation and test in Europe},
  year = {2001},
  pages = {760--765},
  address = {Munich, Germany},
  publisher = {{IEEE} Press},
  abstract = {We present a new hardware-software co-simulation framework enabling
	fast prototyping in system-on-chip designs. On the software side,
	the machine description language LISA allows the generation of bit-true
	models of programmable architectures on various levels – from instruction-set
	to phase accuracy. Based on these models, a complete tool-suite consisting
	of fast compiled processor simulator, assembler, linker, HLL-compiler
	as well as cosimulation interface can be generated automatically.
	On the hardware side, the SystemC simulation class library is employed
	and enhanced with our generic co-simulation interface that enables
	the coupling of hardware and software models specified at various
	levels of abstraction. Besides that, a hardware modeling strategy
	using abstract macrocycle based C++ processes to increase hardware
	modeling efficiency and simulation speed is presented.},
  isbn = {0-7695-0993-2},
  owner = {delbianc},
  timestamp = {2009.10.08},
  url = {http://portal.acm.org/citation.cfm?id=367072.367949}
}

@ARTICLE{Hsiung2000,
  author = {{Pao-Ann} Hsiung},
  title = {Embedded software verification in hardware-software codesign},
  journal = {J. Syst. Archit.},
  year = {2000},
  volume = {46},
  pages = {1435--1450},
  number = {15},
  keywords = {embedded software, quasi-static scheduling, software synthesis, software
	verification, symbolic model checking, system/process concurrency,
	todo:read},
  owner = {delbianc},
  timestamp = {2009.10.12},
  url = {http://portal.acm.org/citation.cfm?id=365989.366000}
}

@INCOLLECTION{Hubbers2004,
  author = {Engelbert Hubbers and Martijn Oostdijk and Erik Poll},
  title = {Implementing a Formally Verifiable Security Protocol in Java Card},
  booktitle = {Security in Pervasive Computing},
  year = {2004},
  pages = {213--226},
  abstract = {This paper describes a case study in refining an security protocol
	description down to a concrete implementation on a Java Card smart
	card. The aim is to consider the decisions that have to be made in
	the development of such an implementation in a systematic way, and
	to investigate the possibilities of formal specification and verification
	in the design process and for the final implementation.},
  owner = {delbianc},
  timestamp = {2009.10.12},
  url = {http://www.springerlink.com/content/9r15nl8bgwmwtjte}
}

@BOOK{Marchesi2003,
  title = {Extreme Programming and Agile Processes in Software Engineering},
  year = {2003},
  author = {Michele Marchesi and Giancarlo Succi},
  owner = {delbianc},
  url = {http://dx.doi.org/10.1007/3-540-44870-5}
}

@INPROCEEDINGS{Marick1999,
  author = {Brian Marick},
  title = {{How to Misuse Code Coverage}},
  booktitle = {Proceedings of the 16th international conference on Testing Computer
	Software},
  year = {1999},
  pages = {16---18},
  owner = {delbianc},
  timestamp = {2009.10.12},
  url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.42.9868}
}

@ARTICLE{Martin1996,
  author = {Robert Cecil Martin},
  title = {The dependency inversion principle},
  journal = {C++ Report},
  year = {1996},
  volume = {8},
  pages = {61--66},
  number = {6},
  owner = {delbianc}
}

@BOOK{Meyer1997,
  title = {Object-Oriented Software Construction},
  publisher = {Prentice Hall},
  year = {1997},
  author = {Bertrand Meyer},
  address = {Upper Saddle River, NJ},
  edition = {Second},
  abstract = {The developer of the acclaimed Eiffel programming language comes through
	with one of the clearest and most informative books about computers
	ever committed to paper. The book is the gospel of object-oriented
	technology and it deserves to be spread everywhere. Meyer opens with
	coverage of the need for an object-oriented approach to software
	development, citing improved quality and development speed as key
	advantages of the approach. He then explains all the key criteria
	that define an object- oriented approach to a problem. Meyer pays
	attention to techniques, such as classes, objects, memory management,
	and more, returning to each technique and polishing his readers'
	knowledge of it as he explains how to employ it well. In a section
	on advanced topics, Meyer explores interesting and relevant topics,
	such as persistent objects stored in a database. He also offers a
	sort of Do and Don't section in which he enumerates common mistakes
	and ways to avoid them. Management information isn't the main point
	of Object-Oriented Software Construction, but you'll find some in
	its pages. Meyer concludes his tour de force with comparisons of
	all the key object-oriented languages, including Java. He also covers
	the potential of simulating object technology in non-object-oriented
	languages, such as Pascal and Fortran.},
  biburl = {http://www.bibsonomy.org/bibtex/2bcacee55fd29e37910ebca67c8fa52c8/flint63},
  file = {InformIT Product page:http\://www.informit.com/title/0136291554:URL;Amazon Search inside:http\://www.amazon.de/gp/reader/0136291554/:URL;Google Books:http\://books.google.de/books?isbn=978-0-13-629155-8:URL},
  isbn = {978-0-13-629155-8},
  owner = {delbianc}
}

@MISC{Oriat2004,
  author = {Catherine Oriat},
  title = {Jartege: a Tool for Random Generation of Unit Tests for Java Classes},
  howpublished = {{http://adsabs.harvard.edu/abs/2004cs.......12012O}},
  month = dec,
  year = {2004},
  abstract = {This report presents Jartege, a tool which allows random generation
	of unit tests for Java classes specified in {JML.} {JML} {(Java}
	Modeling Language) is a specification language for Java which allows
	one to write invariants for classes, and pre- and postconditions
	for operations. As in the {JML-JUnit} tool, we use {JML} specifications
	on the one hand to eliminate irrelevant test cases, and on the other
	hand as a test oracle. Jartege randomly generates test cases, which
	consist of a sequence of constructor and method calls for the classes
	under test. The random aspect of the tool can be parameterized by
	associating weights to classes and operations, and by controlling
	the number of instances which are created for each class under test.
	The practical use of Jartege is illustrated by a small case study.},
  annote = {rate: C
	
	not so smart approach (random tests) does no seem to be a scalable
	approach no real world example, as usual no complex formalization,
	as usual
	
	to be cited references
	
	},
  journal = {{ArXiv} Computer Science e-prints},
  keywords = {{ACM:} D.2, D.2.5, Programming Languages},
  owner = {delbianc},
  shorttitle = {Jartege},
  timestamp = {2009.10.12},
  url = {http://adsabs.harvard.edu/abs/2004cs.......12012O}
}

@INCOLLECTION{PaigeBrooke2005,
  author = {Richard Paige and Phillip Brooke},
  title = {{Agile Formal Method Engineering}},
  booktitle = {Integrated Formal Methods},
  year = {2005},
  pages = {109--128},
  abstract = {Software development methods are software products, in the sense that
	they should be engineered by following a methodology to meet the
	behavioural and non-behavioural requirements of the intended users
	of the method. We argue that agile approaches are the most appropriate
	means for engineering new methods, and particularly for integrating
	formal methods. We show how agile principles and practices apply
	to engineering methods, and demonstrate their application by integrating
	parts of the Eiffel development method with {CSP.}},
  owner = {delbianc},
  url = {http://dx.doi.org/10.1007/11589976_8}
}

@INPROCEEDINGS{Ryzhyk2009,
  author = {Leonid Ryzhyk and Peter Chubb and Ihor Kuz and Gernot Heiser},
  title = {Dingo: taming device drivers},
  booktitle = {Proceedings of the 4th {ACM} European conference on Computer systems},
  year = {2009},
  pages = {275--288},
  address = {Nuremberg, Germany},
  publisher = {{ACM}},
  abstract = {Device drivers are notorious for being a major source of failure in
	operating systems. In analysing a sample of real defects in Linux
	drivers, we found that a large proportion (39\%) of bugs are due
	to two key shortcomings in the device-driver architecture enforced
	by current operating systems: poorly-defined communication protocols
	between drivers and the {OS,} which confuse developers and lead to
	protocol violations, and a multithreaded model of computation that
	leads to numerous race conditions and deadlocks.},
  doi = {10.1145/1519065.1519095},
  isbn = {978-1-60558-482-9},
  keywords = {concurrent programming, device drivers, domain-specific languages,
	fault avoidance, reliability, todo:read},
  owner = {delbianc},
  shorttitle = {Dingo},
  timestamp = {2009.10.08},
  url = {http://portal.acm.org/citation.cfm?id=1519095}
}

@ARTICLE{Siegmund2002,
  author = {R. Siegmund and D. Muller},
  title = {Automatic synthesis of communication controller hardware from protocol
	specifications},
  journal = {Design \& Test of Computers, {IEEE}},
  year = {2002},
  volume = {19},
  pages = {84--95},
  number = {4},
  abstract = {Controllers for serial protocols are control-oriented designs that
	include complex state machines. Manually designing protocol controllers
	is thus tedious, error prone, and time-consuming. We present a new
	methodology for the efficient design of communication controller
	hardware suited for (but not limited to) complex, bit-serial protocols.
	Our methodology synthesizes controller hardware from a formal high-level
	specification of the protocol. In this approach, a single run of
	the synthesis algorithm synthesizes a complete communication architecture
	from a single protocol specification. The method not only reduces
	modeling effort but also ensures that both the interacting transaction
	producer and consumer controllers conform to the initial protocol
	specification},
  issn = {0740-7475},
  keywords = {automatic communication controller hardware synthesis, complex bit-serial
	protocols, complex state machines, formal high-level specification,
	formal specification, protocols},
  owner = {delbianc},
  timestamp = {2009.10.08}
}

@ARTICLE{silva_reconcilingirreconcilable?software_????,
  author = {J. G. Silva and P. R. Cunha},
  title = {Reconciling the irreconcilable? A software development approach that
	combines Agile with Formal},
  shorttitle = {Reconciling the irreconcilable?}
}

@ARTICLE{Slomka2000,
  author = {F. Slomka and M. Dorfel and R. Munzenberger and R. Hofmann},
  title = {Hardware/software codesign and rapid prototyping of embedded systems},
  journal = {Design \& Test of Computers, {IEEE}},
  year = {2000},
  volume = {17},
  pages = {28--38},
  number = {2},
  abstract = {The complexity and the short time to market of embedded systems require
	the use of automated techniques during the specification, implementation,
	and testing phases of such systems. Due to the cost requirements
	and the timing constraints of such systems, application-specific
	hardware solutions are often needed, making the codesign of hardware
	and software a major topic for the design automation of embedded
	systems. This article describes tools for the analysis, synthesis,
	and rapid prototyping of distributed embedded real-time systems and
	presents a complete design flow from specification to implementation},
  doi = {10.1109/54.844331},
  issn = {0740-7475},
  keywords = {application-specific hardware solutions, complexity, computational
	complexity, design flow, embedded systems, formal specification,
	hardware-software codesign, hardware/software codesign, rapid prototyping,
	real-time systems, software prototyping, specification, timing constraints},
  owner = {delbianc},
  timestamp = {2009.10.08}
}

@BOOK{Stapleton1997,
  title = {Dynamic Systems Development Method},
  publisher = {Addison Wesley},
  year = {1997},
  author = {J. Stapleton},
  biburl = {http://www.bibsonomy.org/bibtex/2b4a70ae29741870bf7e43cb1c66da64e/magsilva},
  owner = {delbianc}
}

@INCOLLECTION{Stojanovic2003,
  author = {Zoran Stojanovic and Ajantha Dahanayake and Henk Sol},
  title = {{Component-Oriented} Agile Software Development},
  booktitle = {Extreme Programming and Agile Processes in Software Engineering},
  year = {2003},
  pages = {1011},
  abstract = {Agile Development {(AD),} {Model-Driven} Development {(MDD)} and {Component-Based}
	Development {(CBD)} have been proposed, each on its own, as the ways
	to build quality software systems fast and be able to easily adapt
	to frequently changing requirements in the environment. This paper
	presents how component concepts can support and strengthen {AD} principles
	and practice, help in overcoming {AD} limitations, as well as bridge
	the gap between {AD} and {MDD} by combining certain elements from
	both sides.},
  owner = {delbianc},
  url = {http://dx.doi.org/10.1007/3-540-44870-5_38}
}

@ARTICLE{Suhaib2005,
  author = {Syed M. Suhaib and Deepak A. Mathaikutty and Sandeep K. Shukla and
	David Berner},
  title = {{XFM:} An incremental methodology for developing formal models},
  journal = {{ACM} Trans. Des. Autom. Electron. Syst.},
  year = {2005},
  volume = {10},
  pages = {589--609},
  number = {4},
  abstract = {We present an agile formal methodology named {eXtreme} Formal Modeling
	{(XFM),} based on Extreme Programming {(XP)} concepts to construct
	abstract models from natural language specifications of complex systems.
	In particular, we focus on Prescriptive Formal Models {(PFMs)} that
	capture the specification of the system under design in a mathematically
	precise manner. Such models can be used as golden reference models
	for formal verification, test generation, coverage monitor generation,
	etc. This methodology for incrementally building {PFMs} works by
	adding user stories expressed as {LTL} formulae gleaned from the
	natural language specifications, one by one, into the model. {XFM}
	builds the models, retaining correctness with respect to incrementally
	added properties by regressively model-checking all the {LTL} properties
	captured theretofore in the model. We illustrate {XFM} with a graded
	set of examples consisting of a traffic light controller and a {DLX}
	pipeline. To make the regressive model-checking steps feasible with
	current model-checking tools, we need to control the model size increments
	at each subsequent step in the process. We therefore analyze the
	effects of ordering the {LTL} properties in {XFM} on the statespace
	growth rate of the model. We compare three different property-ordering
	methodologies: ad hoc ordering, property-based ordering, and predicate-based
	ordering. We experiment on the models of the {ISA} bus monitor and
	the arbitration phase of the Pentium Pro bus. We experimentally show
	and mathematically reason that the predicate-based ordering is the
	best among these orderings. Finally, we present a {GUI-based} toolbox
	that we implemented to build {PFMs} using {XFM.}},
  doi = {10.1145/1109118.1109120},
  keywords = {extreme formal modeling, extreme programming, formal specification,
	formal verification, prescriptive formal models, property ordering,
	property refactoring, smv, spin},
  owner = {delbianc},
  shorttitle = {{XFM}},
  url = {http://portal.acm.org/citation.cfm?id=1109120}
}

@ARTICLE{Tan2004,
  author = {Roy Patrick Tan and Stephen H. Edwards},
  title = {Experiences Evaluating the Effectiveness of {JML-JUnit} Testing},
  journal = {{ACM} {SIGSOFT} Software Engineering Notes},
  year = {2004},
  volume = {29},
  pages = {1--4},
  number = {5},
  month = sep,
  abstract = {This paper reports on the issues the authors encountered while evaluating
	the {JML-JUnit} unit testing strategy. Given a predefined set of
	parameter values, {JML-JUnit} can automatically provide unit tests
	for Java programs that have specifications. We present a mutation
	testing experiment that evaluates the effectiveness of this testing
	strategy, and the lessons learned from doing this experiment. We
	conclude that a benchmark will enable the testing research community
	to meaningfully assess testing approaches.},
  annote = {rate: C--
	
	wrong approach?: compare unit tests vs integration tests approach
	is not assessed: mutation analysis, is it effective? mutation tool:
	is it complaint to mutation analysis? it appears it is not specification
	used are good? it appears they aren't some good ideas
	
	to be cited
	
	},
  keywords = {Benchmarking, Communities, Java (programming language), {JML,} Mutations,
	Software engineering, Specifications, Strategy},
  owner = {delbianc},
  timestamp = {2009.10.12}
}

@BOOK{Thomas2004,
  title = {Java testing patterns},
  publisher = {John Wiley \& Sons},
  year = {2004},
  author = {Thomas, J.},
  owner = {delbianc}
}

@INPROCEEDINGS{turk_limitations_????,
  author = {D. Turk and R. France and B. Rumpe},
  title = {Limitations of agile software processes}
}

@MISC{Valderrama1995,
  author = {A. Changuel C. A. Valderrama},
  title = {A unified model for co-simulation and co-synthesis of mixed hardware/software
	systems},
  howpublished = {{http://www2.computer.org/portal/web/csdl/doi/10.1109/EDTC.1995.470395}},
  month = mar,
  year = {1995},
  abstract = {This paper presents a methodology for a unified co-simulation and
	co-synthesis of hardware-software systems. This approach addresses
	the modeling of communication between the hardware and software modules
	at different abstraction levels and for different design tools. The
	main contribution is the use of a multi-view library concept in order
	to hide specific hardware/software implementation details and communication
	schemes. A system is viewed as a set of communicating hardware {(VHDL)}
	and software {(C)} sub-systems. The same C, {VHDL} descriptions can
	be used for both co-simulation and hardware-software co-synthesis.
	This approach is illustrated by an example.},
  keywords = {todo:read},
  owner = {delbianc},
  timestamp = {2009.10.08},
  type = {text},
  url = {http://www2.computer.org/portal/web/csdl/doi/10.1109/EDTC.1995.470395}
}

@MANUAL{ftdi_d2xx_api_2009,
  title = {Software Application Development D2XX's Programmer's Guide. {FT 000071}},
  organization = {Future Technology Devices International Chip},
  edition = {1.01},
  year = {2009},
  owner = {delbianc},
  timestamp = {2009.08.04}
}

@MANUAL{ftdi_ft232h_2009,
  title = {FT2232H Dual High Speed USB to Multipurpose UART/FIFO IC. {FT 000061}},
  organization = {Future Technology Devices International Chip},
  edition = {2.05},
  year = {2009},
  owner = {delbianc},
  timestamp = {2009.08.04}
}

