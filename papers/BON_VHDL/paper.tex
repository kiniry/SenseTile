%
% "Refining from the BON High-level Specification Language to the
% VHDL Hardware Description Language" for UNKNOWN09.
% Joseph R. Kiniry, Dragan Stosic
% $Id: paper.tex 2795 2007-09-23 19:35:53Z dmz $
%

\documentclass{article} 
\usepackage{times}
\usepackage{multirow}
\usepackage{ifpdf}
\usepackage{a4wide}
\usepackage{pdfsync}
\usepackage{amsmath}
\usepackage{listings}

\ifpdf
\usepackage[pdftex]{graphicx}
\else
\usepackage{graphicx}
\fi

%\usepackage{todonotes}

% \usepackage{html}
% \usepackage{url}
\usepackage{xspace}
%\usepackage{doublespace}
\usepackage{tabularx}
\usepackage{epsfig}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{eucal}
\usepackage{stmaryrd}
% \ifpdf
% \usepackage[centredisplay]{diagrams}
% \else
% \usepackage[centredisplay,PostScript=dvips]{diagrams}
% \fi
\usepackage{float}

\ifpdf
\usepackage[pdftex,bookmarks=false,a4paper=false,
            plainpages=false,naturalnames=true,
            colorlinks=true,pdfstartview=FitV,
            linkcolor=blue,citecolor=blue,urlcolor=blue,
            pdfauthor="Joseph R. Kiniry and Dragan Stosic"]{hyperref}
\else
\usepackage[dvips,linkcolor=blue,citecolor=blue,urlcolor=blue]{hyperref}
\fi


\lstset{
  language=Java,
  basicstyle=\footnotesize\sffamily,
  identifierstyle=\itshape,
  stringstyle=\footnotesize\ttfamily,
  commentstyle=\textup,
  columns=flexible,
  captionpos=b,
  morekeywords={},
  literate=
  {-}{{$\textendash$}}1
  {<}{{$\textless$}}1
  {<=}{{$\textless=$}}1
  {>}{{$\textgreater$}}2
  {>=}{{$\textgreater=$}}2
  {\\}{{$\backslash\backslash$}}1
  {'}{{$\textprimstress$}}1
}

\def\lstinlinen{\lstinline[language=Bon,basicstyle=\normalsize\upshape]}

\def\lstinlinenv{\lstinline[language=VHDL,basicstyle=\normalsize\upshape]}

\def\lstinlinenc{\lstinline[language=VHDL,basicstyle=\normalsize\bfseries]}

\def\lstinlinenb{\lstinline[language=Bon,basicstyle=\normalsize\bfseries]}

\lstdefinelanguage{Bon} {
  morekeywords={require,ensure,feature,old,and,o,Q'slew,end,Result, Void},
  morekeywords={class_chart,class,delta,invariant,inherit,deferred,effective,NONE,make},
  morekeywords={explanation,query,command,constraint},
  morecomment=[l]{--}, 
  morecomment=[s]{/*}{*/}, 
  morestring=[b]", 
 literate=,
  showstringspaces=false
}

\lstdefinelanguage{VHDL} {
  morekeywords={not,xnor,and,nand, nor,or,xor,integer,byte,real},
  morekeywords={character,enum,type,boolean,bit,time,null,std_ulogic},
  morekeywords={sll, srl, sla, sra, rol, ror},
  morekeywords={rem,abs,mod},
  morekeywords={terminal,T'reference, T'contribution,T'tolerance},
  morekeywords={reference,contribution},
  morekeywords={nature,subnature,electrical,magnetic,translational,translational_v},
  morekeywords={rotational,rotational_v,fluidic,thermal,radiant},
  morekeywords={voltage,angular_velocity,pressure,velocity},
  morekeywords={current,force,torque,volumetric,flow_rate},
  morekeywords={T'left,T'right,T'high,T'ascending,T'image(x),T'value(s)},
  morekeywords={left,right,high,ascending,image,value},
  morekeywords={T'pos(s),T'val(x),T'succ(x),T'pred(x)},
  morekeywords={pos,val,succ,pred},
  morekeywords={A'left(n),A'right(n),A'low(n),A'high(n)},
  morekeywords={left,right,low,high},
  morekeywords={A'range(n),A'reverse_range(n),A'length(n),A'ascending(n)},
  morekeywords={range,reverse_range,length,ascending},
  morekeywords={T'leftof(x),T'rightof(x),T'base},
  morekeywords={leftof,rightof,base},
  morekeywords={Q'tolerance, Q'above,Q'delayed,Q'dot,Q'integ},
  morekeywords={delayed,dot,integ},
  morekeywords={Q'slew,Q'ztf,Q'ltf,Q'zoh},
  morekeywords={N'across, N'through},
  morekeywords={across,through,zoh,ltf,slew,ztf},
  morekeywords={above,tolerance,group,quantity},
  morecomment=[l]{--}, 
  morecomment=[s]{/*}{*/}, 
  morestring=[b]", 
 literate=,
  showstringspaces=false
}

\newcommand{\tablesize}{\footnotesize}
\newcommand{\eg}{e.g.,\xspace}
\newcommand{\ie}{i.e.,\xspace}
\newcommand{\etc}{etc.\xspace}
\newcommand{\myhref}[2]{\ifpdf\href{#1}{#2}\else\htmladdnormallinkfoot{#2}{#1}\fi}
%\newcommand{\myhref}[2]{\emph{#2}}
\newcommand{\todo}{\textbf{TODO:}}
\newcommand{\ST}{\emph{SenseTile}\xspace}
\newcommand{\STs}{\emph{SenseTiles}\xspace}
\newcommand{\STS}{\emph{SenseTile Simulator}\xspace}
\newcommand{\datastore}{\STs Scientific Datastore\xspace}
\newcommand{\computefarm}{The \STs Scientific Compute Farm\xspace}
\newcommand{\computefarmlong}{UCD CASL \STs Software and Data Compute Server Farm\xspace}
\newcommand{\sensorfarm}{The \STs\xspace}
\newcommand{\ent}{\emph{entity}\xspace}
\newcommand{\arch}{\emph{architecture}\xspace}
\newcommand{\archs}{\emph{architectures}\xspace}

\newcommand{\undef}{\emph{undefined}\xspace}
\newcommand{\arcoss}{\emph{across}\xspace}
\newcommand{\through}{\emph{through}\xspace}
%---------------------------------------------------------------------
% New commands, macros, \etc
%---------------------------------------------------------------------

%% \input{kt}

%=====================================================================

\begin{document}

\title{Refining from the BON High-level Specification Language to the
  VHDL-AMS Hardware Description Language}

\author{Joseph R. Kiniry and Dragan Stosic\\
UCD CASL: Complex and Adaptive Systems Laboratory and\\
School of Computer Science and Informatics,\\
University College Dublin,\\
Belfield, Dublin 4, Ireland,\\
kiniry@acm.org and dragan.stosic@gmail.com\\
}

\maketitle

%======================================================================
%\thispagestyle{empty}
\begin{abstract}
  
The \textbf{UCD CASL SenseTile System} is a large-scale, general-purpose
sensor system installed at the University College Dublin in Dublin,
Ireland.  \textbf{Our facility provides a capability---unique in the world in
terms of its scale and flexibility---for performing in-depth
investigation of both the specific and general issues in large-scale
sensor networking.}

This system integrates a sensor platform, a datastore, and a compute
farm.  The sensor platform is a custom-designed, but inexpensive,
sensor platform (called the \ST) paired with general-purpose
small-scale compute nodes, including everything from low-power PDAs to
powerful touchscreen-based portable computers.  The datastore is a
multi-terabyte scale scientific datastore into which sensor data
flows, and in which online and offline scientific computation of
sensor and other scientific data takes place.  The compute farm is a
large-scale Linux, Solaris, and OS~X-based compute farm used by
scientists for these online and offline scientific computations.

The \STs, as an embedded system, have several unusual built-in sensors 
and emitters, sensor nodes can be extended via a general-purpose USB bus, 
and \STs contain an FPGA that is dynamically updated on a per-experiment 
basis.  \STs are custom-designed in VHDL and VHDL-AMS.  Like many hardware-based systems,
 to write new software for or against the \ST architecture one either uses
the actual hardware or one runs a \STS.  But this simulator emulates a
piece of hardware, one would like to know if the simulator
\emph{actually} simulates the hardware.  We have developed an approach
through which we refine the VHDL specification up to the formal BON
specification language, and from this specification we generate an
executable, functional model-based specification in the JML language.
We have used this specification to implement a fully validated and
verified \ST simulator.

\end{abstract}

%======================================================================
\section{Introduction}
The \STs, represents heterogeneous collection of digital, analog 
and mixed signal hardware components. Embedded system complexity 
requires the need to strive for formal descriptions each component 
separatelly in order to produce specification of the \STs simulator. 
The development of complex system requires sophisticated tool and methodology 
in order to be able to complete a correct design in time.  
The authors will illustrate in this paper how BON can represent a high 
level analogue mapping and will further illustrate a procedure for 
transformation from VHDL-AMS to BON. As an extremly simple example, 
we will give practical aspect of refinement from VHDL-AMS to BON,
applied on A/D convertor, in order to produce formal specification 
and software simulation. A comprehensive list of the mapping between BON 
and VHDL-AMS can be found in the appendix.
%=====================================================================


\section{VHDL-AMS}
IEEE VHDL-AMS 1076.1 is the industry standard mixed-signal 
high-level description language for electronic and multi-domain 
systems. VHDL-AMS, as an superset of VHDL, supports modeling and 
simulation of analog and mixed-signal systems. The main contribution 
of VHDL-AMS is ability to describe the behavior of complex system 
trought differential and algebraic equations (DAEs). For this purpose, 
VHDL-AMS introduces the following capabilities and therms:

\begin{itemize}
\item 
\emph{Terminals} represents phisical connection points or circuit nodes 
of a network connectivity. They are declared to be of various 
\emph{natures}, which represent different energy domains of a system.
Terminals hold no values; their only role is to facilitate the formation
of conservative equation sets that, in turn, constrain the associated 
\emph{branch quatities}. 
\item
The \emph{simultaneous statements} creates one or more characteristic 
equations that are solved by the dedicated simulation kernel a.k.a.
"analog solver", to model continuously valued behaviour.  
\item
The \emph{quantities} denote a waveform or a time series of values.
The behaviour of the \emph{quantities} is given by the \emph{simultaneous
 statements}. They take values as a result of solving the set of simultaneous 
ordinary differential and algebraic equations (DAEs). To simplify, 
quantities can be understood as analog unknowns of (DAEs) that specify 
analog behavior. There are three kinds of quantity in VHDL-AMS: free, 
branch and source quantities. A \emph{free quantity} can be used in 
signal-flow modeling. A \emph{branch quantity} is used to model conservative energy
systems. A \emph{source quantity} is used for frequency and noise modeling.
\item
The \emph{break statement} is an construct which allows to 
initialize the DAE system at the beginning of a transient 
simulation and to mark discontinuities during such a transient 
simulation. A break statement allows restart of the analog kernel,
than overrides quantity values and executes concurrently with the analogue model. 
For any concurrent break statement there is an associated process.
\end{itemize} 
 
\section{Choice of BON as the modeling tool}
%Brief description and motivation.
The Business Object Notation (BON) is an analysis and design notation 
for object-oriented systems  which emphasizes \emph{seamlessness}, 
\emph{reversibility} and software \emph{contracting}. Let us define 
these principles precisely and point out why the principles are 
important in VHDL-AMS simulation.

\subsection{Seamlessness and Reversibility}
\emph{Seamlessness} is the use of a continuous process 
throughout the software lifecycle.
\emph{Reversibility} is the support for both forward and 
backward development process: from analysis to design 
and implementation, and back.
In VHDL-AMS, modelling represents an continious top-down-bottom-up
process. Top-down approach serves for design while bottom-up
serves for verification. The possibility of seamlessly translating 
changes made during a certain development phase back into earlier phases,
facilitates a stable and predictable environment and ensures the various 
models consistent with the code. Keeping in sync various models, documetation
and specification from forward progress to backward and redesign, preclude 
that design and implementation diverge to an inconsistent state. 
\emph{Seamlessness} also plays important role in relating behaviours at 
differing levels of abstraction. For example, one may wish to relate the 
structural views of an A/D converter at the level of individual bits and 
at the level of busses. Therefore capturing similarities between the 
differing levels of abstractions far outweigh their inevitable differences, 
making it possible to obtain a continuous process that ensures a direct 
mapping between a formal specification and its software solution.
    
\subsection{Contracting and Refinement}
\emph{Contracting} is the definition, for each software element, 
of the associated semantic properties. BON use a full assertion mechanism, 
allowing analysts to specify not only the structure of a system but also its
semantics ( constraints and invariants of the expected results ). 
In VHDL-AMS \emph{simultaneous statement} represents analogue constraint of 
continuous-time waveform. In other words, analog kernel calculate quantities such 
that the constraints specified by the simultaneous statements are satisfied. 
We will agree that the constraint of waveform is nothing else than \emph{invariant}.
Another example of \emph{invariant} is conservation of energy law in which 
the summation of \arcoss quantities (\texttt{$\sum_{loop}$ across quatities =0}) 
around any loop equals zero and the summation of through 
quantities (\texttt{$\sum_{node}$ through quatities =0}) at any node equals zero. 
Moreover, any predefined (implicite) attribute in VHDL 
has defined pre(post) condition trought input(output) 
parameters and theirs constraints. Furthermore any subtype(subnature) 
represents restricted set of values from a base type(nature). 
The condition that determines which values are in the subtype(subnature)  
may be contracted by specifying characteristic predicate. 
For example, in typed $\lambda$ calculi, the VHDL-AMS subtype \lstinlinenc|bit| of 
\lstinlinenc|integer|, may be defined as \texttt{bit:=$\lambda$ n:nat.n < 2}. 
The corresponding informal and formal BON transformations are shown 
by the example below:
\input{bitbon}
Therefore as an notition based on contract design, and as  methodology of 
best modelling practices, BON is the obvious choice for the our simulator.
Throughout this paper we will try to make this more clearly.  

\section{Mapping between VHDL-AMS and BON}


\section{Refinement from VHDL-AMS to BON }
 
An VHDL-AMS design units are described using an \ent-\arch structure. 
The design unit contains an \ent and one or more \archs. 
The \ent specifies the interface that an entity provides of itself 
to the outside. In other words, \ent introduces a name, list of 
input/output ports and the definition of the generic parameters. 
The textual presentation of \ent is shown in Figure.1. 
\input{adc-entity}
 
The \arch body represents description of the internal implementation 
of an \ent including only process statements(encapsulation), which 
are collections  of actions to be executed in sequence, or simultaneous statements, 
which describe equations of analogue system behaviour. 
The textual presentation of \arch is shown in Figure.2.
\input{adc-arch}

%=====================================================================
\section{Conclusion}

A conclusion.

\section {Acknowledgments}
The research upon which this paper is based was caried out with
sponsorship from Science Foundation Ireland via the 
\textbf{UCD CASL SenseTile System} grant.


%% \nocite{ex1,ex2}
\bibliographystyle{plain}
\bibliography{extra,%
              abbrev,%
              ads,%
              category,%
              complexity,%
              hypertext,%
              icsr,%
              knowledge,%
              languages,%
              linguistics,%
              meta,%
              metrics,%
              misc,%
              modeling,%
              modeltheory,%
              reuse,%
              rewriting,%
              softeng,%
              specification,%
              ssr,%
              technology,%
              theory,%
              web,%
              upcoming,%
              upcoming_conferences,%
              conferences,%
              workshops,%
              verification,%
              escjava,%
              jml,%
              nijmegen}

%======================================================================
% Fin

%======================================================================
\appendix
\newpage
\section {APPENDIX}
\input{static}
\input{arith}
\input{shift}
\input{relation}
\input{logic}
\input{types}
\input{assignment}
\input{iscaltypeattr}
\input{tolerance}
\input{effort}
\input{flow}
\input{nature}
\input{iscalnature}
\input{iarrayattr}
\input{scalnat}
\input{iterminal}
\input{terminal}
\input{iquantity}
\input{quantity}
\input{quantityport}
\input{terminalport}
\input{signal}
\input{signalattr}
\input{wait}
%======================================================================

\end{document}

%%% Local Variables: 
%%% mode: latex
%%% eval: 
%%% TeX-master: t
%%% End: 
