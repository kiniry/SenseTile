%
% "Refining from the BON High-level Specification Language to the
% VHDL Hardware Description Language" for UNKNOWN09.
% Joseph R. Kiniry, Dragan Stosic
% $Id: paper.tex 2795 2007-09-23 19:35:53Z dmz $
%

\documentclass{article}
\usepackage{times}
\usepackage{multirow}
\usepackage{ifpdf}
\usepackage{a4wide}
%\usepackage{pdfsync}
\usepackage{amsmath}
\usepackage{listings}

\ifpdf
\usepackage[pdftex]{graphicx}
\else
\usepackage{graphicx}
\fi

%\usepackage{todonotes}

% \usepackage{html}
% \usepackage{url}
\usepackage{xspace}
%\usepackage{doublespace}
\usepackage{tabularx}
\usepackage{epsfig}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{eucal}
\usepackage{stmaryrd}
% \ifpdf
% \usepackage[centredisplay]{diagrams}
% \else
% \usepackage[centredisplay,PostScript=dvips]{diagrams}
% \fi
\usepackage{float}
\usepackage{subfig}

\ifpdf
\usepackage[pdftex,bookmarks=false,a4paper=false,
            plainpages=false,naturalnames=true,
            colorlinks=true,pdfstartview=FitV,
            linkcolor=blue,citecolor=blue,urlcolor=blue,
            pdfauthor="Joseph R. Kiniry and Dragan Stosic"]{hyperref}
\else
\usepackage[dvips,linkcolor=blue,citecolor=blue,urlcolor=blue]{hyperref}

\fi
\ifpdf
  \DeclareGraphicsRule{*}{mps}{*}{}
\fi
\def\figureautorefname{Fig.}

\lstset{
  language=Java,
  basicstyle=\footnotesize\sffamily,
  identifierstyle=\itshape,
  stringstyle=\footnotesize\ttfamily,
  commentstyle=\textup,
  columns=flexible,
  captionpos=b,
  morekeywords={},
  literate=
  {-}{{$\textendash$}}1
  {<}{{$\textless$}}1
  {<=}{{$\textless=$}}1
  {>}{{$\textgreater$}}2
  {>=}{{$\textgreater=$}}2
  {'}{{$\textprimstress$}}1
}

\def\sectionautorefname{Section}

\def\lstinlinen{\lstinline[language=Bon,basicstyle=\normalsize\upshape]}

\def\lstinlinenv{\lstinline[language=VHDL,basicstyle=\normalsize\upshape]}

\def\lstinlinenc{\lstinline[language=VHDL,basicstyle=\normalsize\bfseries]}

\def\lstinlinenb{\lstinline[language=Bon,basicstyle=\normalsize\bfseries]}

\lstdefinelanguage{Bon} {
  morekeywords={require,ensure,feature,old,and,o,Q'slew,end,Result, Void},
  morekeywords={class_chart,class,delta,invariant,inherit,deferred,effective,NONE,make},
  morekeywords={explanation,query,command,constraint,exists,for_all,such_that,it_holds},
  morecomment=[l]{--},
  morecomment=[s]{/*}{*/},
  morestring=[b]",
 literate=,
  showstringspaces=false
}

\lstdefinelanguage{VHDL} {
  morekeywords={not,xnor,and,nand, nor,or,xor,integer,byte,real},
  morekeywords={character,enum,type,boolean,bit,time,null,std_ulogic},
  morekeywords={sll, srl, sla, sra, rol, ror},
  morekeywords={rem,abs,mod,to},
  morekeywords={terminal,T'reference, T'contribution,T'tolerance},
  morekeywords={reference,contribution},
  morekeywords={nature,subnature,electrical,magnetic,translational,translational_v},
  morekeywords={rotational,rotational_v,fluidic,thermal,radiant},
  morekeywords={voltage,angular_velocity,pressure,velocity},
  morekeywords={current,force,torque,volumetric,flow_rate},
  morekeywords={T'left,T'right,T'high,T'ascending,T'image(x),T'value(s)},
  morekeywords={left,right,high,ascending,image,value},
  morekeywords={T'pos(s),T'val(x),T'succ(x),T'pred(x)},
  morekeywords={pos,val,succ,pred},
  morekeywords={A'left(n),A'right(n),A'low(n),A'high(n)},
  morekeywords={left,right,low,high},
  morekeywords={A'range(n),A'reverse_range(n),A'length(n),A'ascending(n)},
  morekeywords={range,reverse_range,length,ascending},
  morekeywords={T'leftof(x),T'rightof(x),T'base},
  morekeywords={leftof,rightof,base},
  morekeywords={Q'tolerance, Q'above,Q'delayed,Q'dot,Q'integ},
  morekeywords={delayed,dot,integ},
  morekeywords={Q'slew,Q'ztf,Q'ltf,Q'zoh},
  morekeywords={N'across, N'through},
  morekeywords={across,through,zoh,ltf,slew,ztf},
  morekeywords={above,tolerance,group,quantity},
  morekeywords={entity,end,use,port,generic,is,library,all},
  morekeywords={architecture,of,through,begin,constant},
  morecomment=[l]{--},
  morecomment=[s]{/*}{*/},
  morestring=[b]",
 literate=,
  showstringspaces=false
}

\newcommand{\tablesize}{\footnotesize}
\newcommand{\eg}{e.g.,\xspace}
\newcommand{\ie}{i.e.,\xspace}
\newcommand{\etc}{etc.\xspace}
\newcommand{\myhref}[2]{\ifpdf\href{#1}{#2}\else\htmladdnormallinkfoot{#2}{#1}\fi}
%\newcommand{\myhref}[2]{\emph{#2}}
\newcommand{\todo}{\textbf{TODO:}}
\newcommand{\ST}{\emph{SenseTile}\xspace}
\newcommand{\STs}{\emph{SenseTiles}\xspace}
\newcommand{\STS}{\emph{SenseTile Simulator}\xspace}
\newcommand{\datastore}{\STs Scientific Datastore\xspace}
\newcommand{\computefarm}{The \STs Scientific Compute Farm\xspace}
\newcommand{\computefarmlong}{UCD CASL \STs Software and Data Compute Server Farm\xspace}
\newcommand{\sensorfarm}{The \STs\xspace}
\newcommand{\ent}{entity\xspace}
\newcommand{\arch}{architecture\xspace}
\newcommand{\archs}{architectures\xspace}
\newcommand{\inv}{\emph{invariant}\xspace}
\newcommand{\undef}{\emph{undefined}\xspace}
\newcommand{\arcoss}{\emph{across}\xspace}
\newcommand{\through}{\emph{through}\xspace}
\newcommand{\notej}[1]{\xspace$\frac{\varocircle}{\textsf{jk}}$\marginpar{\scriptsize\textsf{Joe:}
    #1}}

%---------------------------------------------------------------------
% New commands, macros, \etc
%---------------------------------------------------------------------

%% \input{kt}

%=====================================================================

\begin{document}

\title{Refining from the VHDL-AMS Hardware Description Language 
to the BON High-level Specification Language}

\author{Joseph R. Kiniry and Dragan Stosic\\
UCD CASL: Complex and Adaptive Systems Laboratory and\\
School of Computer Science and Informatics,\\
University College Dublin,\\
Belfield, Dublin 4, Ireland,\\
kiniry@acm.org and dragan.stosic@gmail.com\\
}

\maketitle

%======================================================================
%\thispagestyle{empty}
\begin{abstract}

Complex software engineering projects often use high-level
specification languages to describe system abstractions.  These
abstractions, which typically capture static and dynamic architectural
aspects, are meant to be more approachable, comprehensible, and useful
than witnessing the gory details of the systems they describe.  In the
hardware world, systems are described with hardware description
languages like VHDL.  These languages exist at a similar level of
abstraction as traditional software programming languages, like Java.
But whence are the high-level hardware description languages?
Moreover, if one is doing hardware/software co-design, what
architecture description languages are usable and useful to both
facets of the problem domain?  In this paper, we describe a
non-trivial co-design effort, called SenseTile, and how requirements
on its design and verification led us to define a formal refinement of
VHDL-AMS to the EBON high-level specification language.  This
refinement enables us to abstract away, in a seamless, reversible, and
contract-based fashion, from the details of a particular hardware
system to an neutral architecture description which, in turn, can be
refined to an executable Java-based software simulator.  This pair of
refinements permits full round-trip hardware/software co-design with
verification, as the Java-based system is annotated with formal
specifications using the Java Modeling Language.

\end{abstract}

%======================================================================
\section{Introduction}
\label{sec:introduction}

The \textbf{UCD CASL SenseTile System} is a large-scale,
general-purpose sensor system under development at the University
College Dublin in Dublin, Ireland.  \emph{After its installation, it
  is our intention that this facility will provide a
  capability---unique in the world in terms of its scale and
  flexibility---for performing in-depth investigation of both the
  specific and general issues in large-scale sensor networking.}  This
system integrates a \emph{sensor platform}, a \emph{datastore}, and a
\emph{compute farm}.

The \emph{sensor platform} is a custom-designed, but inexpensive,
sensor platform called the \ST.  Each \ST is paired with
general-purpose, small-scale compute node ranging is capability from a
low-power PDA to a powerful touchscreen-based portable computer.  

The \emph{datastore} is a multi-terabyte scale scientific datastore
located in a server room across campus.  Sensor data flows into this
datastore during experiments.  It is also used for online and offline
computation of sensor and other scientific data.

The \emph{compute farm} is a large-scale Linux, Solaris, Windows, and
OS~X-based compute farm used by scientists for these computations.

\subsection{The \ST}
\label{subsec:st}

The \STs contain several built-in sensors, ranging from typical
sensors like temperature and humidity to more unusual ones like
ultrasonic microphones.  They also contain several emitters, including
visible and infrared light, audible and ultrasonic sound, and more.
Sensor nodes are extended via a USB bus, and \STs contain an FPGA that
is dynamically updated on a per-experiment basis.

\STs are custom-designed by a third party based upon our high-level
specifications in VHDL-AMS.  Common to many hardware prototype
development efforts, writing software for the \ST architecture means
either using the actual hardware, or running a \STS.  But this
simulator must emulate a piece of hardware \emph{that does not yet
  exist}.  Worse, as is typical with these kinds of development
efforts, the hardware is several quarters late, and the show must go
on.

Consequently, the \STS becomes the primary focus of development
efforts and, as we do not wish to loose any development time, we would
like to know if the simulator \emph{actually} simulates the hardware,
thus ensuring that the software we write for the simulator will run
immediately on the hardware when it arrives.

\subsection{Software}
\label{subsec:software}

Complementing these hardware development efforts, the software
architecture that runs the \STs is under development.  This system
consists of a low-level USB driver written in C and a packet framer
and control system written in Java.

It is vitally important that these low-level software systems are
well-understood, work correctly from day zero, and have adequate
non-functional characteristics---primarily that they do not use too
much memory or CPU on the low-power devices for which they are
destined.  As such, and following the standard development conventions
of our research group, they are formally specified using the BON and
JML specification languages.  Moreover, they are validated and
verified using various forms of testing and static analysis, all of
which are the focus of several other papers.

\subsection{Co-design}
\label{subsec:co-design}

Even in the best of hardware-software co-design processes, hardware
development typically focuses on correctness through rigorous
specification, static analysis, and simulation, while software
development uses the ``by the seat of the pants'' approach.  As is
obvious from the previous section, that does not fly in our research
group.

Consequently, we have developed an approach through which we abstract
(via a formal refinement) a VHDL-AMS specification up to a formal BON
specification.  Using this specification, we then generate (again, via
a formally defined refinement) an executable, functional, model-based
specification in the JML language.  We have subsequently used this
specification to implement a fully validated and verified \ST
simulator.  

Due to the semantic properties of these refinements, as seen
in~\autoref{diagram}, we are guaranteed that all functional properties
of the original VHDL-AMS specification are preserved in the software
simulator, thereby witnessing full hardware-software co-design in a
formal sense.

In summary, this article provides three main contributions.
\begin{enumerate}
\item We define a relation between a hardware description language,
  VHDL-AMS, and a high-level specification language (BON).  This
  relation means that, given a well-formed VHDL-AMS program, it can be
  described using a BON (informal/formal) specification, and hence to
  a JML implementation, through a sequence of refinements.
\item We describe how to formally emulate piece of hardware using a
  refinement-based approach.  Our approach uses object-oriented
  languages, including a high-level and a low-level specification
  language, BON and JML respectively.
\item We introduce the use of \emph{invariants} as a general concept
  for modeling hardware components behavior and their interactions.
  To be more precise, the behavioral specification of a hardware
  component is represented as an invariant on the signals at a
  circuit's ports, which in turn is derived from the conjunction of
  the invariants that describe behaviors of the component's
  subsystems.
\end{enumerate} 

The rest of this article is organized as follows.  In
\autoref{sec:vhdlams} we present an overview of VHDL-AMS language.
\autoref{sec:choiceobon} defines BON principles and explains the
reasons why we have used the BON method.  In \autoref{sec:mappingVB}
the relation between VHDL-AMS and BON is summarized.  A comprehensive
description of the mapping between BON and VHDL-AMS is found in a
separate technical report.  This refinement is applied to a small
example in \autoref{sec:refVB}, in which we abstract from a passive RC
low-pass filter in order to produce formal specification and software
simulation.  In \autoref{sec:conclusion} we reflect on this work and
point to some open problems and research opportunities.
 
%=====================================================================
\section{VHDL-AMS}
\label{sec:vhdlams} 

The VHDL-AMS language, defined by IEEE VHDL-AMS 1076.1, is the
industry standard mixed-signal high-level description language for
electronic and multi-domain systems.  VHDL-AMS, as an superset of
VHDL, supports modeling and simulation of \emph{analog} and
mixed-signal systems.  

\subsection{Key Qualities of VHDL-AM}
\label{subsec:key-qualities-vhdl}

The main contribution of VHDL-AMS is ability to describe the behavior
of a complex system through differential and algebraic equations
(DAEs).  For this purpose, VHDL-AMS introduces the following
notions:
\begin{itemize}
\item \emph{Terminals} represents physical connection points or
  circuit nodes of a network connectivity.  Each terminal has a
  \emph{nature}, which represents different energy domains of a
  system.  Terminals hold no values---their only role is to facilitate
  the formation of conservative equation sets that, in turn, constrain
  the associated \emph{branch qualities}.

\item \emph{Quantities} denote a waveform or a time series of values.
  The behavior of the \emph{quantities} is given through the use of
  \emph{simultaneous statements}.  Quantities take values as a result
  of solving a set of simultaneous ordinary differential and algebraic
  equations (DAEs).  \notej{We need a concrete example here.  This
    does not make much sense in isolation.  Perhaps this detail should
    just be moved or replicated later.  -JRK}

  To simplify, quantities are understood as analog unknowns of (DAEs)
  that specify analog behaviour.  There are three kinds of quantities
  in VHDL-AMS: free, branch, and source quantities.  A \emph{free
    quantity} is used in signal-flow modeling.  A \emph{branch
    quantity} is used to model conservative energy systems.  A
  \emph{source quantity} is used for frequency and noise modeling.

\item \emph{Simultaneous statements} define one or more characteristic
  equations that are solved by the dedicated simulation kernel, a.k.a.
  an "analog solver," to model continuously valued behavior.

\item \emph{Procedural statements} express analog behaviour using
  sequential statements. Actually, procedural statements describe
  analog behaviour by computing new values for quantities from the
  current value of quantities.

\item The \emph{break statement} is an construct used to initialize
  the DAE system at the beginning of a transient simulation, and to
  mark discontinuities during such a transient simulation.  For any
  concurrent break statement there is an associated process.  A break
  statement allows restart of the analog kernel, than overrides
  quantity values and executes concurrently with the analogue model.
  \notje{I have no idea what this last sentence means. -JRK}
\end{itemize}

\subsection{A Running Example: A Low-Pass Filter}
\label{subsec:lptransfunc} 

\input{lowpassRC} 

A simple low-pass filter is a passive RC network shown in
\autoref{fig:lowpassfig}.  According to the equation given above (see
\autoref{fig:transfun}), we can produce VHDL-AMS \emph{simultaneous
  statement} using \texttt{$s = d/dt = 'dot$} relation.  The
transformation looks as follows:
\begin{equation}
v_{in} = v_{out} + \tau_psv_{out} 
   \begin{array}[b]{c}                                                                                                                                    
      {\scriptscriptstyle s = d/dt}  \\=                                                                                                                  
   \end{array} 
v_{out} + \tau_p\cfrac{dv_{out}}{dt}
\begin{array}[b]{c}                                                                                                                                    
      {\scriptscriptstyle d/dt = } {\scriptscriptstyle 'dot} \\=                                                                                                                  
   \end{array}
  v_{in} = v_{out} + \tau_pv_{out}{'dot} 
\end{equation} 

This last equation is interpreted as follows.  The input voltage
($v_{in}$) equals the sum of output voltage ($v_{out}$) and
multiplication of the time constant ($\tau_p$) of the pole and the
first derivative of the capacitor's voltage ($v_{out}{'dot}$) over
time.

Now we discretize previous equation.  Let us represent $v_{in}$ by a
series of samples $v_{in(1..n)}$.  At the same points in time, we
represent $v_{out}$ by a series of samples $v_{out(1..n)}$.  We assume
that samples are taken at points in time incrementing by $\triangle$t.

Now we have equivalent equations:
\begin{equation}
  v_{in(i)}- v_{out(i)}=\tau_p(\frac{v_{out(i)}- v_{out(i-1)}}
  {\triangle t});
\end{equation}

\begin{equation}
  v_{out(i)}=v_{in(i)}(\frac{\triangle t}{\tau_p + \triangle t}) +
  v_{out(i-1)}(\frac{\tau_p}{\tau_p + \triangle t});                                                                \end{equation}

\begin{equation}
  v_{out(i)} 
 \begin{array}[b]{c}
   {\scriptscriptstyle \alpha= \triangle t / (\tau_p + \triangle t)}
   \\=
 \end{array}
 \alpha v_{in(i)} + (1- \alpha) v_{out(i-1)};                                                                           \end{equation}

The last equation gives us a way to calculate the output samples in
terms of the input samples and the preceding output.  

But how to represent these unknowns in BON\notej{This whole last bit
  should be moved to after we introduce BON and the VHDL-AMS
  metamodel.}?  We introduce the \lstinlinen|BRANCH_QUANTITY| objects
like wrappers around unknowns, with features as follows:
\begin{itemize}
\item \emph{across} which represent current:$i_{out}$ 
\item \emph{through} which represent voltage: $v_{in}$, $v_{out}$. 
\item \emph{terminal sequences} which describes input/output
  terminal(s). 
\end{itemize}

%===================================================================== 
\section{The Business Object Notation}
\label{sec:choiceobon} 

The Business Object Notation (BON) is an analysis and design notation
for object-oriented systems which supports \emph{seamlessness},
\emph{reversibility}, and software \emph{contracting}.  Let us define
these principles precisely and point out why they are important in
VHDL-AMS simulation.

\paragraph{Seamlessness and Reversibility} \emph{Seamlessness} is the
use of a continuous process throughout the software life-cycle.
\emph{Reversibility} is the support for both forward and backward
development process: from analysis to design and implementation, and
back.  

In VHDL-AMS, modeling represents an continuous top-down/bottom-up
process.  A top-down approach supports design, while bottom-up
supports verification.  The possibility of seamlessly translating
changes made during a certain development phase back into earlier
phases facilitates a stable and predictable environment and ensures
the various models consistent with the code.  Keeping in sync various
models, documentation and specification from forward progress to
backward and redesign preclude that design and implementation diverge
to an inconsistent state.

\emph{Seamlessness} also plays an important role in relating behaviors
at different levels of abstraction.  For instance, one may wish to
analyze a lowpass-filter at the level of individual components (a
resistor and capacitor) and their behaviours or, at the more abstract
level, through general behaviour expressed via an invariant.
Therefore, capturing similarities between the differing levels of
abstractions makes it possible to obtain a continuous process that
ensures a direct mapping between a formal specification and its
software solution.

\paragraph{Contracting} Contract specifications describe system
components and their interactions based on mutual obligations, and,
for each software element, its associated semantic properties.  BON
use an assertion mechanism, supporting analysts' need to specify
both:~(1) the \emph{structure} of a system, and (2)~the
\emph{semantics} of a system via a set of constraints and invariants.

The common way to specify a program statement is to give a
\emph{precondition} and \emph{postcondition} on the state that the
implementation must satisfy, assuming that only certain program
variables are changed.  In VHDL-AMS, any predefined (implicate)
attribute has defined \emph{pre} (\emph{post}) \emph{condition}
through input (output) parameters and their constraints.  Furthermore,
any subtype (subnature) represents restricted set of values from a
base type (nature).  The condition that determines which values are in
the subtype (subnature) may be contracted by specifying a
characteristic predicate which represents an invariant.

Let us next look how \emph{simultaneous statements} are handled in
contract-based design.  The \emph{simultaneous statement} represents
analogue constraint of continuous-time waveform.  We will assume that
the constraint of a waveform is represented by an invariant. This
premise deserves an informal explanation.

Briefly stated, the analog kernel calculates quantities such that the
constraints specified by the simultaneous statements are satisfied.
More accurately, \emph{simultaneous statements} can be thought of as
algebraic equations.  It means that the number of simultaneous
statements should be equal to the number of unknowns
(\emph{quantities}).  

For instance, when we reasoning about the conservation of energy law,
the \emph{simultaneous statements} constrain the values of
\emph{branch quantities} in a model.  In other words, the sum of
\arcoss quantities (\texttt{$\sum_{loop}$ across quatities =0}) around
any closed path must be equal to zero and the sum of \through
quantities (\texttt{$\sum_{node}$ through quatities =0}) at any node
(terminal) must be equal to zero.  To be more precise, the results of
summations above remains zero when a particular transformation is
applied to quantities.  In general, they are invariant.

However, if our implementation does not satisfy the conservation of
energy law, then the invariant will be broken.  Another conclusion may
be deducted from the example given above.

Intuitively \inv may be useful for testing the function of the
hardware components.  In practice, one can runs simulator against the
component in order to check the properties. Testing can then be done
by checking whether the \inv hold or not.  For example, the most
common problem of the real components is the glich - an electrical
pulse of short duration that is usually the result of a design error.
The number of glitches that occur can be known by the fact how many
times per day, the \inv was broken and reestablished. According to
that we can conclude whether the quality of a component is
satisfactory. Unlike in the case of software, where correction of an
error is relatively inexpensive, an detected hardware error may
require product replacement, which is associated with great expenses.
In other words, we cannot patch a fabricated component once we started
massive production.

%=====================================================================
\section{Mapping between VHDL-AMS and BON}
\label{sec:mappingVB} 

In this section, we briefly describe the mapping between VHDL-AMS and
BON notation which is discussed in the points below.

\textbf{Structure} \xspace \xspace VHDL-AMS allows hierarchical
structure modeling, meaning that the model subsystems can be developed
independently.  As an top-level description, \lstinlinen|SYSTEM_CHART|
in the BON notation can connect all the model subsystems together to a
model design.  In BON, model subsystem is denoted as the
\lstinlinen|CLUSTER_CHART| whereas module is represented as the
\lstinlinen|CLASS_CHART|.  Each module has a \texttt{port} interface:
a set of \emph{inputs} and \emph{outputs} used for connecting modules
with environment. The \texttt{port} section in \texttt{\ent}structure
(input, output and generic values) are represented as a
\emph{features} in the \lstinlinen|CLASS_CHART|.  The
\lstinlinen|CLASS_CHART| \xspace can be equated with \ent-\arch
structure in VHDL-AMS and the name of the
\lstinlinen|CLASS_CHART|\xspace corresponds to the name of
\texttt{\ent}in VHDL-AMS.
 
\textbf{Behavior} \xspace \xspace The module also contains an
\texttt{\arch} implementation, which determines the way the module
processes \emph{input}/\emph{output} signals and performs
computations.  The \emph{constraint} section in the
\lstinlinen|CLASS_CHART| contains the transfer function and holds the
same information as the \texttt{\arch}section of the VHDL-AMS.
 
\textbf{Types and operators} \xspace \xspace There are many features
of VHDL-AMS which are already mapped in BON by default, such as
arithmetic, relational and logical operators and types like \xspace
\texttt{integer}, \xspace
\texttt{byte},\xspace\texttt{real},\xspace\texttt{character} and
\xspace\texttt{boolean}.  Vector may be represented as
\lstinlinen|SEQUENCE[TYPE]|, whereas record, whose elements are of
heterogeneous types, can be mapped as \lstinlinen|SET| or
\lstinlinen|TABLE|.  In BON, the \texttt{time} can be represented as
the \lstinlinen|UNIVERSAL_TIME|, in order to specify
\emph{delays}. Actually time can be thought of as object with integer
as a value and measurement units as a \xspace \lstinlinen|SEQUENCE|
feature.  In order to specify energy domain for nodes of circuits we
have developed various standard \texttt{nature} templates for
\texttt{terminals}.  We have introduced
\xspace\lstinlinen|FREE|,\xspace \lstinlinen|BRANCH| and
\xspace\lstinlinen|SOURCE| \space \lstinlinen|QUANTITY| objects, which
are intended to describe signal-flow modeling, the conservation of
energy low and frequency-noise related problems.  There are also
defined specifications for effort and flow domains, tolerance as well
as appropriate contracts for scalar types(natures), array
types(natures), terminals and quantity attributes.  Whereas the value
assignment, in VHDL-AMS has the same purpose as in the BON, the signal
assignment, which schedules a new value to be applied to a signal
later, is simulated in specification, but denotational semantic is not
yet translated in the BON as well as for concurrency and the
\texttt{wait} statement.
  
\section{Refinement from VHDL-AMS to BON }
\label{sec:refVB} The main theme of this article is the translation
from VHDL-AMS to BON using refinement approach.  We will refine the
VHDL-AMS code up to the formal BON, and from this specification we
will generate an executable specification in the JML language.  For
this purpose, we will demonstrate our approach in BON-JML fashion
trought low-pass filter example.

\subsection{Refine example }
\label{subsec:refine}     
We have not yet said what specification and refinement are.  Let us
introduce these terms first.

A \emph{specification} of a program component is a contract that gives
some constraints on how the component is to behave but leaves freedom
for the implementator to decide how the actual behavior of the
component is to be realized.  As we have shown in
\autoref{tab:rescapfirst}, corresponding informal specifications
represents high level of abstraction derived from VHDL-AMS code.

A \emph{refinement} represents the concept that can be understood as
series of correctness-preserving transformations from general
perspective to a precise level of detail. Accurately, if we compare
two specifications, \texttt{S} and \texttt{S'}, then we can conclude
that the \texttt{S} is more abstract than \texttt{S'} if any condition
that we can establish with the first specification can also be
established by second.  It means that "\texttt{S is \emph{refined} by
S'}", and we denote this as \texttt{S $\sqsubseteq$ S'}.  The
\emph{refinement} which was derived in three steps, from informal to
more formal BON and finally to JML, is represented using relation
\texttt{$\sqsubseteq$}. This relation represent \emph{isomorphism} and
has inverse relation \texttt{$\sqsupseteq$}.  It means that once we
have more formal specification, we can refine and seamlessly translate
specification in previous abstract level, keeping specification
validity and documentation consistency.  In other words, we use two
important BON principles to achieve as much as precise model
consistency: the seamlessness and reversibility(see
\autoref{sec:choiceobon}).  Let say that the first informal BON
specification is denoted by \texttt{S} (see
\autoref{tab:rescapfirst}), and second and third, which are given in
\autoref{tab:rescapsecond} is denoted by \texttt{S',S''}.  The forward
process refinement can be represented as:\xspace \texttt{S
$\sqsubseteq$ S' $\sqsubseteq$ S''}, while the backward process can be
represented as \xspace \texttt{S''$\sqsubseteq$ S' $\sqsubseteq$ S}.
Using all BON principles, we have developed an specification of RC
low-pass filter, and we have produced fully validated and verified
low-pass filter.  \input{lowpass1} \input{lowpass2}

%=====================================================================
\section{Conclusion}
\label{sec:conclusion} 

The BON notation has originally been used for description of software
models. However, after certain elaboration it can be used for
description of hardware components. Practical utilization of the
approach in the project on mapping between VHDL-AMS and BON using
refinement technique, has demonstrated through low-pass filter example
and shown that simulation of component requires relatively little and
inexpensive efforts. Moreover, our article shown that the development
of the specification produced by the BON and translated into JML can
be applied as refinement procedure: from VHDL-AMS to informal BON,
next, from informal to more formal BON and finally, to JML
specification.  The BON support general software development and
should be adapted for concrete applications and language as
VHDL-AMS. For this purpose we have developed various VHDL-AMS related
types, operators and relations and we have defined appropriate
specifications for all of them. However, the behavior of
\texttt{break} statement and concurrency, for example, have not been
translated yet in the BON notation. We have started a new phase of
project named \emph{eBon} in which the issues mentioned above, and
creation of appropriate components and relations are main subject.

\section {Acknowledgments} The research upon which this article is
based was caried out with sponsorship from Science Foundation Ireland
via the \textbf{UCD CASL SenseTile System} grant.


%% \nocite{ex1,ex2}
\bibliographystyle{plain}
\bibliography{extra,%
              abbrev,%
              ads,%
              category,%
              complexity,%
              hypertext,%
              icsr,%
              knowledge,%
              languages,%
              linguistics,%
              meta,%
              metrics,%
              misc,%
              modeling,%
              modeltheory,%
              reuse,%
              rewriting,%
              softeng,%
              specification,%
              ssr,%
              technology,%
              theory,%
              web,%
              upcoming,%
              upcoming_conferences,%
              conferences,%
              workshops,%
              verification,%
              escjava,%
              jml,%
              nijmegen}

%======================================================================
% Fin

%======================================================================
\appendix
\newpage
\section {APPENDIX}
\input{static}
\input{arith}
\input{shift}
\input{relation}
\input{logic}
\input{types}
\input{assignment}
\input{iscaltypeattr}
\input{tolerance}
\input{effort}
\input{flow}
\input{nature}
\input{iscalnature}
\input{iarrayattr}
\input{scalnat}
\input{iterminal}
\input{terminal}
\input{iquantity}
\input{quantity}
%\input{quantityport}
%\input{terminalport}
%\input{signal}
%\input{signalattr}
%\input{wait}
%\input{bitbon}
%======================================================================

\end{document}

%%% Local Variables:
%%% mode: latex
%%% eval:
%%% TeX-master: t
%%% End:

