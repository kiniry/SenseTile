refinement[T1,T2: TYPE]: THEORY
BEGIN
  IMPORTING refines_t[T1,T2]
  t1: VAR p_transf
  t2: VAR p_transf

  |-(t1,t2):bool = refines(t1,t2)

  AUTO_REWRITE+ |-

  extract: [T1 -> T2]
  generate: [T2 -> T1]

  refinement_ref: LEMMA extract |- extract;
  
 
END refinement

%
%set_refinement
%
set_refinement[a, b: TYPE]: THEORY
BEGIN

  IMPORTING refinement[set[a], set[b]]

END set_refinement
 
%
%predicate_transformers
%
predicate_trans[T:TYPE] :THEORY
BEGIN

p,q,r : VAR PRED[T]
true     :PRED[T] = (LAMBDA (u:T): TRUE);
false    :PRED[T] = (LAMBDA (u:T): FALSE);
and(p,q) :PRED[T] = (LAMBDA (u:T): p(u) AND q(u));
or(p,q)  :PRED[T] = (LAMBDA (u:T): p(u) OR q(u));
not(q)   :PRED[T] = (LAMBDA (u:T): NOT q(u));
|>(p,q)  :bool = (FORALL (u:T): p(u) IMPLIES q(u));
iff(p,q) :bool = (p |> q) AND (q |> p)

AUTO_REWRITE+ true, false, and, or, not,|>, iff;

implies_reflexivity : LEMMA p |> p

implies_transitivity: LEMMA (p |> r)  AND 
                      (r |> q)  IMPLIES  (p |> q)

END predicate_trans

%
%refines_t
%
refines_t[T1, T2: TYPE]: THEORY
BEGIN

IMPORTING predicate_trans
                                                  
p_transf : TYPE = [PRED[T1] -> PRED[T2]]

c, c1, c2 :VAR  p_transf

monotonic(c):bool = FORALL (p,q:PRED[T1]): (p |> q) => (c(p) |> c(q));

% refinement relation - definition
refines(c1,c): bool = FORALL (q:PRED[T1]): c(q)|> c1(q)

AUTO_REWRITE+ refines 

refines_reflexivity: LEMMA refines(c,c)

refines_transitivity: LEMMA refines(c1,c) AND 
                      refines(c2,c1) => refines(c2, c)

END refines_t





