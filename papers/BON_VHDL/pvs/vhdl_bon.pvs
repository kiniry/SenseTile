refinement[T1,T2: TYPE]: THEORY
BEGIN
  IMPORTING refines_t[T1,T2]
  t1: VAR p_transf
  t2: VAR p_transf

  |-(t1,t2):bool = refines(t1,t2)

  AUTO_REWRITE+ |-

  extract: [T1 -> T2]
  generate: [T2 -> T1]

  refinement_ref: LEMMA extract |- extract;
  
 
END refinement

%
%set_refinement
%
set_refinement[a, b: TYPE]: THEORY
BEGIN

  IMPORTING refinement[set[a], set[b]]

END set_refinement
 
%
%predicate_implication
%
predicate_implication[T:TYPE] :THEORY
BEGIN

p,q,r : VAR PRED[T]

|>(p,q): bool = (FORALL (u:T): p(u) IMPLIES q(u));

AUTO_REWRITE+ |>;

implies_reflexivity : LEMMA p |> p

implies_transitivity: LEMMA (p |> r)  AND 
                      (r |> q)  IMPLIES  (p |> q)

END predicate_implication

%
%refines_t
%
refines_t[T1, T2: TYPE]: THEORY
BEGIN

IMPORTING predicate_implication 
                                                  
p_transf : TYPE = [PRED[T1] -> PRED[T2]]

c, c1, c2 :VAR  p_transf

monotonic(c):bool = FORALL (p,q:PRED[T1]): (p |> q) => (c(p) |> c(q));

% refinement relation - definition
refines(c1,c): bool = FORALL (q:PRED[T1]): c(q)|> c1(q)

AUTO_REWRITE+ refines 

refines_reflexivity: LEMMA refines(c,c)

refines_transitivity: LEMMA refines(c1,c) AND 
                      refines(c2,c1) => refines(c2, c)

END refines_t




