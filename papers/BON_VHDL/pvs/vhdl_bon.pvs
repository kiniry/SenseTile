refinement[i,m: TYPE]: THEORY
BEGIN
IMPORTING refines_t

 mod: VAR m
 imp: VAR i

 extract: [i -> m] = {e: [i -> m] | surjective?(e)}; 
 generate:[m -> i] = {g: [m -> i] | injective?(g)};

 |-: PRED[[m,i]] = {(mod:m,imp:i) | generate(mod)= imp and mod = extract(imp)}

  AUTO_REWRITE+ extract, generate,|-

  % model   |-   model'
  %  /\ --------->|
  %   |           |
  %   |extract    |generate
  %   |           |
  %   |           |
  %   |           V 
  %   impl------->impl' 
  %         |-
         
  
  % model   |-   model'
  %   | --------->/\
  %   |           |
  %   | generate  | extract
  %   |           |
  %   V --------->|
  % impl  |-  impl'


  %            model
  %  ||          |      /\
  % generate  |- |      ||
  %  ||          |    extract
  %  \/          |      ||
  %            impl

  ax_model_implement: AXIOM ( FORALL(prm:PRED[m]): (FORALL (pri: PRED[i]): prm(mod) => pri(imp))) 

%  lemma_comxp_ext_ge: LEMMA FORALL (mod:m ): o(extract,generate)(mod) = mod 
%  lemma_comp_ge_ext: LEMMA FORALL (imp:i ): o(generate,extract)(imp) = imp 
  
END refinement


%%%%%%% PARTIAL ORDER REWRITING %%%%%%%%%

p_order_rewrite[T : TYPE+ , <=:(partial_order?[T])]: THEORY
BEGIN

p,q,r : VAR T

is_reflexive: LEMMA p <= p

is_antisymmetric: LEMMA p <= q AND q <= p =>  p = q

is_transitive: LEMMA p <= q AND q <= r => p <= r

END p_order_rewrite






%refinement_semantics[I,M: TYPE]: THEORY
%BEGIN
% left_adjoint: AXIOM = (FORALL r: refinement[I,M]):
%                         (FORALL e: extract | ref?(e) = r):
%                            (FORALL g: generate | ref?(g) = r):
%                               (FORALL i: I)
%                                  e(g(i)) = i
%END refinement_semantics

%
%set_refinement
%
set_refinement[T, R: TYPE]: THEORY
BEGIN
  IMPORTING refinement[set[T], set[R]]
END set_refinement
 
%%%%%PREDICATE TRANSFORMER%%%%%%%
predicate_trans[T:TYPE] :THEORY
BEGIN
 
p,q,r : VAR PRED[T]

t: VAR T

true     :PRED[T] = (LAMBDA (u:T): TRUE);

false    :PRED[T] = (LAMBDA (u:T): FALSE);

and(p,q) :PRED[T] = (LAMBDA (u:T): p(u) AND q(u));

or(p,q)  :PRED[T] = (LAMBDA (u:T): p(u) OR q(u));

not(q)   :PRED[T] = (LAMBDA (u:T): NOT q(u));

|>(p,q)  :bool = (FORALL (u:T): p(u) IMPLIES q(u));

iff(p,q) :bool = (p |> q) AND (q |> p);



<=> :(iff)

abort(q):bool  = false

magic(q):bool  = true

select(p)(r):PRED[T] = { s:(r) | p(s) }

AUTO_REWRITE+ true, false, and, or, not,|>,iff,<=>;

implies_reflexivity : LEMMA p |> p

implies_transitivity: LEMMA (p |> r)  AND 
                      (r |> q)  IMPLIES  (p |> q)

implies_antisymmetry:LEMMA (p |> r)  AND 
		      ( r |> p ) => p = r

% Implication and equivalence on predicate 
% transformers can also be defined as 
% pointwise extension: 

impl_lema: LEMMA (p |>q )=> (p(t) => q(t)) 

eqv_lema : LEMMA ( iff(p,q) )=> p(t) = q(t)

every_select: LEMMA every(p)(select(p)(r))


END predicate_trans



%%%%%%% REFINES THEORY %%%%%%%%%
refines_t[T1, T2: TYPE]: THEORY
BEGIN
IMPORTING predicate_trans

p_transf : TYPE = [PRED[T1] -> PRED[T2]]                                                  

c, c1, c2 :VAR  p_transf

p: VAR PRED[T1]

q: VAR PRED[T2]

t1: VAR T1

monotonic?(c):bool = FORALL (p,q:PRED[T1]): (p |> q) => (c(p) |> c(q));

refines?(c1,c): bool = FORALL (q:PRED[T1]): c(q)|> c1(q) 

AUTO_REWRITE+ refines?, monotonic?

refines_reflexivity: LEMMA refines?(c,c)

refines_transitivity: LEMMA refines?(c1,c) AND 
                      refines?(c2,c1) => refines?(c2, c)
 
refines_antisymmetry: LEMMA refines?(c1,c) AND 
                      refines?(c,c1) => c(t1) = c1(t1)

END refines_t


%%%%%%% SEQUENTIAL COMPOSITION %%%%%%%%%
seq_comp [T1, T2, T3, T4 :TYPE]:THEORY
BEGIN IMPORTING refines_t 

a1, b1 : VAR p_transf[T3, T4]

a2, b2 : VAR p_transf[T2, T3]

a3 : VAR p_transf[T1, T2]

skip: p_transf[T3,T3]  = (LAMBDA (q:PRED [T3]) : q)

lemma_skip_mono:LEMMA monotonic?(skip)

seq_monotonic: LEMMA monotonic?(a1) AND monotonic?(a2)
                      =>  monotonic?(a1 o a2)

seq_mono_refinement : LEMMA monotonic?(b1) AND refines?(b1,a1) 
                            AND refines?(b2,a2) => refines?(b1 o b2, a1 o a2)


seq_mono_refinement2 : LEMMA monotonic?(a1) AND refines?(b1,a1) 
                            AND refines?(b2,a2) => refines?(b1 o b2, a1 o a2)

seq_extensionality : LEMMA (a1 = b1 AND a2 = b2) => (a1 o a2)= (b1 o b2)

seq_extension: LEMMA (a1 = b1) => (a1 o a2) = (b1 o a2)

remove_left_skip : LEMMA refines?( a2, skip  o a2 )

remove_right_skip : LEMMA refines?( a1, a1 o skip )

eliminate_parentheses1 : LEMMA a1 o a2 o a3 = a1 o ( a2 o a3)

eliminate_parentheses2 : LEMMA a1 o a2 o a3 = (a1 o  a2) o a3

END seq_comp


%%%%%%% FIXED POINTS %%%%%%%%%
% Important because garantees the existance of 
% (meet , join) fixed points, which are needed for 
% defining recursion and iteration. 

fixed_point[T:TYPE]: THEORY
BEGIN
IMPORTING refines_t

s : VAR setof[[PRED[T]]]
f:  VAR p_transf [T,T]

p,q : VAR PRED [T]
c, d : VAR p_transf [T,T]


glb(s) : PRED [T] = (LAMBDA (u:T): (FORALL (p:PRED[T]): s(p) => p(u)))

fix(f) : PRED [T] = glb(LAMBDA (p:PRED [T]): f(p) |> p)


gr_lower_lower : LEMMA s(p) => glb(s) |> p

gr_lower_greatest : LEMMA
      (FORALL (r:PRED [T]): s(r) => (q |> r)) => (q |> glb(s))

fix_monotonic: LEMMA monotonic?(f) => f(fix(f)) = fix(f)

fix_point_least: LEMMA (f(p) |> p) => (fix(f) |> p)            

fix_point_mono : LEMMA
      (FORALL (q:PRED [T]): c(q) |> d(q)) => (fix(c) |> fix(d))

END fixed_point





