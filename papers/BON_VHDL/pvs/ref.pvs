refinement[m,i: TYPE+, |-:(partial_order?[m]), |-:(partial_order?[i])]: THEORY
BEGIN
IMPORTING monotonic_f[m,i,|-,|-],
          monotonic_f[i,m,|-,|-],
          pointwise_ext[m,i,|-],
          pointwise_ext[i,m,|-]
 
 %po_ext :THEORY = pointwise_ext[m,i,|-]
 mod: VAR m
 imp: VAR i

 extract: [i -> m] =  {e: [i -> m] |monotonic_f.mono?(e)}; 
 generate:[m -> i] = {g: [m -> i] | monotonic_f.mono?(g)};

 |-: PRED[[m,i]] = {(mod:m, imp:i) | left_inverse?(extract, generate) &
                                     right_inverse?(extract, generate) &
                                     inverse?(extract, generate)&
                                     left_inverse?(generate, extract) &
                                     right_inverse?(generate, extract) &
                                     inverse?(generate, extract) } 
fun_E_set :TYPE = set[[i -> m]]
fun_G_set :TYPE = set[[m -> i]]

%{(mod:m,imp:i) | generate(mod)= imp and mod = extract(imp)}


  AUTO_REWRITE+ extract, generate,|-

  % model   |-   model'
  %  /\ --------->|
  %   |           |
  %   |extract    |generate
  %   |           |
  %   |           |
  %   |           V 
  %   impl------->impl' 
  %         |-
         
  
  % model   |-   model'
  %   | --------->/\
  %   |           |
  %   | generate  | extract
  %   |           |
  %   V --------->|
  % impl  |-  impl'


  %            model
  %  ||          |      /\
  % generate  |- |      ||
  %  ||          |    extract

  %  \/          |      ||
  %            impl

  ax_model_implement: AXIOM ( FORALL(prm:PRED[m]):
         (FORALL (pri: PRED[i]): prm(mod) => pri(imp)))
  
END refinement


 %%%%%%% PARTIAL ORDER REWRITING %%%%%%%%%

po_rewrite[T : TYPE, <=:(partial_order?[T])]: THEORY
BEGIN

p,q,r : VAR T

is_reflexive: LEMMA p <= p

is_antisymmetric: LEMMA p <= q AND q <= p =>  p = q

is_transitive: LEMMA p <= q AND q <= r => p <= r

AUTO_REWRITE+  is_reflexive,is_antisymmetric,is_transitive

END po_rewrite


%%%%%%% PARTIAL ORDER THEORY %%%%%%%%%
partial_order[T:TYPE, <=:(partial_order?[T])]:THEORY
BEGIN

IMPORTING po_rewrite[T,<=] 

t1,t2 : VAR T

A:VAR set[T]
B:VAR set[T]

% Definition of upper and lower bounds (Ralph's meet and join)
% Let B be a subset of poset A. An element a of set A is a lower
% bound of set B if t1 <= a for every t1 member of B. Dually,
% an element of a of A is an upper bound of B if t1 <= a for all
% t1 member of B.

upper_bound?(t1,A):bool  = ( FORALL (a:(A)): a <= t1 );
lower_bound?(t1,A):bool  = ( FORALL (a:(A)): t1 <= a );

% Set of upper bounds and set of lower bounds definitions.
% Ralph's book definition.

UB_set(A):set[T]= {t1: T | upper_bound?(t1,A)};
LB_set(A):set[T]= {t1: T | lower_bound?(t1,A)}; 

% Least upper bound (supremum or join) and 
% Greatest lower bound (infimum or meet )--- definitions.

join?(t1,A):bool = upper_bound?(t1,A) AND 
                                (FORALL (t2:(UB_set(A))): t1 <= t2 )

meet?(t1,A):bool = lower_bound?(t1,A) AND 
		   	        (FORALL (t2:(LB_set(A))): t2 <= t1 ) 
% Existance join and meet definitions
join_exists?(A):bool = EXISTS t1 : join?(t1,A);
meet_exists?(A):bool = EXISTS t1 : meet?(t1,A); 



% Least upper bound exists (def) join exists.
% Greatest lower bound exists (def) meet exists.
Join_exists : TYPE = (join_exists?)
Meet_exists :TYPE  = (meet_exists?)

% Set of meets and joins --- definitions.
Meet_set(A):set[T] = {t1 :T | meet?(t1,A) }
Join_set(A):set[T] = {t1 :T | join?(t1,A) }

%meet and join choice
join(jo:(join_exists?)) : T = choose(Join_set(jo))
meet(me:(meet_exists?)) : T = choose(Meet_set(me))

singleton_join       : LEMMA join?(t1, singleton(t1))
singleton_join_exists: LEMMA join_exists?(singleton(t1))
join_unique_lem: LEMMA join_exists?(A) IMPLIES unique?(Join_set(A))
join_of_singleton: LEMMA join(singleton(t1)) = t1


% -- Maximal and minimal elements
 min?(t1, A): bool = A(t1) 
 	      AND FORALL ( t2: (A)): t2 <= t1 IMPLIES t2 = t1
 
 max?(t1, A): bool = A(t1) 
 	      AND FORALL ( t2: (A)): t1 <= t2 IMPLIES t2 = t1
 
 Min_set(A): set[T] = { t1: T |  min?(t1, A) }
 Max_set(A): set[T] = { t1: T |  max?(t1, A) }


%Chain definition - partial order is linear
chain?(A): bool = nonempty?(A) AND
  FORALL (t1, t2: (A)): (t1 <= t2) OR (t2 <= t1)

Chain : TYPE = (chain?)

JUDGEMENT Chain SUBTYPE_OF (nonempty?[T])


%Least element--- definition

least_element?(t1, A): bool = A(t1) AND lower_bound?(t1, A)

least_elem_is_min: LEMMA least_element?(t1, A) IMPLIES min?(t1, A)

END partial_order


po_rewrite_lemmas[T: TYPE, <=: (partial_order?[T])]: THEORY
 BEGIN

  IMPORTING partial_order[T, <=]

  t1, t2: T

  A: set[T]

  J: VAR (join_exists?)

  JUDGEMENT A HAS_TYPE (nonempty?[T])

  upper_bound_e: LEMMA
    upper_bound?(t1, A) = every(LAMBDA (t2: T): t2 <= t1)(A)

  upper_bound_trans: LEMMA
    upper_bound?(t1, A) AND t1 <= t2 IMPLIES upper_bound?(t2, A)

  join_def_lemma: LEMMA join?(join(J), J)

  singleton_linear: LEMMA chain?(singleton(t1))
 END po_rewrite_lemmas

%%%%%%% POINTWISE EXTENSION FUNCTION DEFINITION %%%%%%%%%
pointwise_ext [D, C: TYPE+, le:(partial_order?[C])]: THEORY

BEGIN

f,g :VAR [D -> C]
t1: VAR D
<=(f, g) : bool = FORALL (t1: D): le(f(t1), g(t1))

pointwise_is_partial_order : LEMMA partial_order?[[ D -> C]](<=)

JUDGEMENT <= HAS_TYPE (partial_order? [[D -> C]])

END pointwise_ext


%%%%%%% MONOTONIC FUNCTION DEFINITION %%%%%%%%%
monotonic_f[D: TYPE, C:TYPE, 
	   le_D:(partial_order?[D]), 
	   le_C:(partial_order?[C])]: THEORY
BEGIN

IMPORTING  partial_order[D,le_D],
	   partial_order[C,le_C] 

f : VAR  [D -> C]

s,s1,s2 : VAR D

t       : VAR C

% Ralph's definition of monotonicity 
mono?(f): bool =
   FORALL s1,s2: le_D(s1,s2) IMPLIES le_C(f(s1),f(s2))

const_monotonic   : LEMMA mono?(LAMBDA s: t)

monotonic_nonempty: LEMMA nonempty?( mono?)

Monotonic: TYPE+ = (mono?)

JUDGEMENT mono? HAS_TYPE (nonempty? [[D->C]])

END monotonic_f





