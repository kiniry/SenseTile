% A theory of higher-order refinement.
% July 2010
refinement[T, U: TYPE,
           (IMPORTING relations[T]) ==: equivalence,
           (IMPORTING relations[U]) ##: relations[U].equivalence,
           gen: [T -> U],
           ext: [U -> T],
           |-: predicate[[T, U]]]: THEORY
BEGIN
  ASSUMING
    t, t0, t1: VAR T
    u, u0, u1: VAR U
    
    generate_consistent_with_refinement: ASSUMPTION t |- gen(t)

    extract_consistent_with_refinement: ASSUMPTION ext(u) |- u

    ext_is_left_inv_of_gen: ASSUMPTION ext(gen(t)) == t

    gen_is_left_inv_of_ext: ASSUMPTION gen(ext(u)) ## u

    gen_preserves_equiv: ASSUMPTION u0 = gen(t0) AND u1 = gen(t1) AND
                                    t0 == t1 IMPLIES u0 ## u1

    ext_preserves_equiv: ASSUMPTION t0 = ext(u0) AND t1 = ext(u1) AND
                                    u0 ## u1 IMPLIES t0 == t1
 ENDASSUMING

  equal_ext_to_equality :LEMMA FORALL((t:T),(u:U)):
                                   u = gen(t) AND t = ext(u)
                                   IMPLIES ext(u)== ext(gen(t))     %-:)


  ref_extract_generate_equal: LEMMA FORALL((t:T),(u:U)):
                                   u ## gen(t) AND t == ext(u)
                                   IMPLIES ext(u) == ext(gen(t))    %-:)


  equal_gen_to_equality :LEMMA FORALL((t:T),(u:U)):
                                   u = gen(t) AND t= ext(u)
                                   IMPLIES gen(t)## gen(ext(u))     %-:)

  ref_generate_extract_equal: LEMMA FORALL((t:T),(u:U)):
                                   u ## gen(t) AND t == ext(u)
                                   IMPLIES gen(t) ## gen(ext(u))    %-:)

  ref_left_composition: LEMMA FORALL ((t:T),(u:U)):
                             u = gen(t) AND
                             |-(t,u) IMPLIES |-(ext(gen(t)),u)      %-:) ?

  ref_right_composition: LEMMA FORALL ((t:T),(u:U)):
                               t = ext(u) AND
                              |-(t,u) IMPLIES |-(t,gen(ext(u)))     %-:) ?

 ref_composition: LEMMA FORALL ((t:T),(u:U)):
                        u = gen(t) AND t = ext(u) AND
                        |-(t,u) IMPLIES |-(ext(gen(t)),gen(ext(u))) %-:) ?

 equivalence_ref_impl: LEMMA FORALL(t0:T),(u0:U):
                             u0 ## gen(t0) AND 
                             t0 == ext(u0) AND 
                             |-(t0,u0) IMPLIES |-(ext(u0),gen(t0))

 
 rep_equiv_ref_impl: LEMMA FORALL(t0:T),(u0:U):
                           u0 ## QuotientDefinition[U].repEC( ## )(gen(t0)) AND 
                           t0 == QuotientDefinition[T].repEC(==)(ext(u0)) AND 
                           |-(t0,u0) IMPLIES |-(ext(u0),gen(t0))

 rep_equiv_ext_ref_impl: LEMMA FORALL(t0:T),(u0:U):
                               u0 ## QuotientDefinition[U].repEC( ## )(gen(t0)) AND 
                               t0 == QuotientDefinition[T].repEC(==)(ext(u0)) AND 
                               |-(t0,u0) IMPLIES |-(QuotientDefinition[T].repEC(==)(ext(u0)),
                                                    QuotientDefinition[U].repEC( ## )(gen(t0)))
END refinement

refinement_model_theory[T, U: TYPE,
                        (IMPORTING relations[T]) ==: equivalence,
                        (IMPORTING relations[U]) ==: relations[U].equivalence,
                        gen: [T -> U],
                        ext: [U -> T],
                        |-: predicate[[T, U]],
                        [||]: [predicate[T] -> predicate[U]],
                        |=: predicate[[T, predicate[T]]],
                        |=: predicate[[U, predicate[U]]]]: THEORY
BEGIN
  ASSUMING
  IMPORTING refinement[T, U, ==, ==, gen, ext, |-]

    p: VAR predicate[T]
    q: VAR predicate[U]
    t: VAR T
    u: VAR U

    interpretation_preserves_validity: ASSUMPTION (t |= p) IMPLIES (u |= [|p|])
  ENDASSUMING
END refinement_model_theory

% What follows is an series of increasingly complex theories that
% highlight different kinds of types between which we define
% refinements.  These are meant to be used for pedagogical and
% illustrative purposes as well as for unit testing the theories.

% Refinement between singleton types, the simplest types we can
% witness in PVS since functions and predicates are total.
singleton_example: THEORY % F x F
BEGIN
  T0: TYPE = {t}
  U0: TYPE = {u}
  IMPORTING relations[T0], relations[U0]

  ==(t0, t1: T0): bool = true;
  ==(u0, u1: U0): bool = true;
  g0: [T0 -> U0] = (LAMBDA (t0: T0): u)
  e0: [U0 -> T0] = (LAMBDA (u0: U0): t)
  ref0: predicate[[T0, U0]] = (LAMBDA (p: [T0, U0]): true)

  IMPORTING refinement[T0, U0, ==, ==, g0, e0, ref0]
END singleton_example

% Refinement between finite sets of nats with trivial equivalence.
finite_nats_trivial: THEORY % F x F (non-trivial)
BEGIN
  T1: TYPE = below(3) % { 0, 1, 2 }
  U1: TYPE = below(6) % { 0, 1, 2, 3, 4, 5 }
  IMPORTING ints@div, relations[T1], relations[U1],
            QuotientDefinition[T1], QuotientDefinition[U1]; 
  
  ==(t0, t1: T1): bool = t0 = t1;
  ==(u0, u1: U1): bool = div(u0,2) = div(u1,2);
  
  g1: [T1 -> U1] = (LAMBDA (t: T1): 2*t)
  e1: [U1 -> T1] = (LAMBDA (u: U1): div(u,2))
  ref1: predicate[[T1, U1]] =
    (LAMBDA (p: [T1, U1]): 2*p`1 = p`2 OR 2*p`1+1 = p`2)

  IMPORTING refinement[T1, U1, ==, ==, g1, e1, ref1]

END finite_nats_trivial 

% Refinement between finite sets of nats with non-trivial equivalence.
finite_nats_non_trivial: THEORY % F x F (equivalence interesting)
BEGIN
  IMPORTING ints@div

  T2: TYPE = below(8) % { 0,1,2,3,4,5,6,7}
  U2: TYPE = below(22)% {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21} 
  IMPORTING relations[T2], relations[U2],
            QuotientDefinition[T2], QuotientDefinition[U2];

  ==(t0, t1: T2): bool =  t0 = t1      OR % {0,0},{0,4},{4,0},
                          t0 + 4 = t1  OR % {1,1},{1,5},{5,1},
                          t1 + 4 = t0;    % {2,2},{2,6},{6,2},
                                          % {3,3},{3,7},{7,3}

% EquivClass/div(elem,3)=0 {0,1,2}   <=> EquivClass/div(elem,3)=4 {12,13,14} AND
% EquivClass/div(elem,3)=1 {3,4,5}   <=> EquivClass/div(elem,3)=5 {15,16,17} AND
% EquivClass/div(elem,3)=2 {6,7,8}   <=> EquivClass/div(elem,3)=6 {18,19,20} AND
% EquivClass/div(elem,3)=3 {9,10,11} <=> EquivClass/div(elem,3)=7 {21}
  ==(u0, u1: U2): bool =  (div(u0,3) = div(u1,3)) OR 
                          abs(div(u0,3) - div(u1,3)) = 4; 
  
  % g2: {0,0},{1,3},{2,6},{3,9},{4,12},{5,15},{6,18},{7,21}
  g2: [T2 -> U2] = (LAMBDA (t: T2): 3*t)
  
  % e2:{0,0},{1,0},{2,0}     {3,1},{4,1},{5,1}     {6,2},{7,2},{8,2}
  %    {9,3},{10,3},{11,3}   {12,4},{13,4},{14,4}  {15,5},{16,5},{17,5}
  %    {18,6},{19,6},{20,6}  {21,7}
  e2: [U2 -> T2] = (LAMBDA (u: U2): div(u,3))
  
  % ref2:{0,0},{0,1},{0,2}   {1,3},{1,4},{1,5}     {2,6},{2,7},{2,0}
  %      {3,9},{3,10},{3,11} {4,12},{4,13},{4,14}  {5,15},{5,16},{5,17}
  %      {6,18},{6,19},{6,20}  {7,21}
  ref2: predicate[[T2, U2]] =
    (LAMBDA (p: [T2, U2]): 3*p`1 = p`2 OR 3*p`1+1 = p`2 OR 3*p`1+2 = p`2)

  IMPORTING refinement[T2, U2, ==, ==, g2, e2, ref2]
END finite_nats_non_trivial

% Refinement between infinite number of trivial equivalance classes  
% in one type and ininfinite sets of nats with a finite number of
% equivalence classes in the other.
% Added Dragan 17.09.2010
infinite_to_infinite_infinite_equival_finite_equival_classes: THEORY % I x I (infinite equiv. x finite equiv)
BEGIN
  IMPORTING ints@div
  T4: TYPE = nat
  U4: TYPE = nat
  IMPORTING relations[T4], relations[U4],
            QuotientDefinition[T4], QuotientDefinition[U4];

  equivT(t0, t1: T4): bool = t0 = t1
  equivU(u0, u1: U4): bool = div(u0,10) = div(u1,10)
  g4: [T4 -> U4] = (LAMBDA (t: T4): 10*t)
  e4: [U4 -> T4] = (LAMBDA (u: U4): div(u,10))
  ref4: predicate[[T4, U4]] = (LAMBDA (p: [T4, U4]): p`1=div(p`2,10))

  IMPORTING refinement[T4, U4, equivT, equivU , g4, e4, ref4]
END infinite_to_infinite_infinite_equival_finite_equival_classes

% @TODO Missing theory to exercise I x I (infinite equiv. x infinite equiv.)
% Solved with posnat as co domain and nat as domain.
% Does it suite for us ?
infinite_to_infinite_infinite_equival_infinite_equival_classes: THEORY % I x I (infinite equiv. x infinite equiv)
BEGIN
  T4: TYPE = nat
  U4: TYPE = posnat
  IMPORTING relations[T4], relations[U4],
            QuotientDefinition[T4], QuotientDefinition[U4];

  equivT(t0, t1: T4): bool = t0 = t1 
  equivU(u0, u1: U4): bool = u0 = u1 
  g4: [T4 -> U4] = (LAMBDA (t: T4): t+1)
  e4: [U4 -> T4] = (LAMBDA (u: U4): u-1)
  ref4: predicate[[T4, U4]] = (LAMBDA (p: [T4, U4]): p`1+1= p`2)

  IMPORTING refinement[T4, U4, equivT, equivU , g4, e4, ref4]
END infinite_to_infinite_infinite_equival_infinite_equival_classes


% Refinement between infinite sets of nats with a finite number of
% equivalence classes.
infinite_nats_finite_equivalence_classes: THEORY % I x I (finite equiv. x finite equiv.)
BEGIN
  IMPORTING ints@div
  T3: TYPE = {n: nat | even?(n)}
  U3: TYPE = {n: nat | odd?(n)}
  IMPORTING relations[T3], relations[U3],
            QuotientDefinition[T3], QuotientDefinition[U3];

  equivT(t0, t1: T3): bool = rem(4)(t0) = rem(4)(t1);
  equivU(u0, u1: U3): bool = rem(4)(u0-1) = rem(4)(u1-1);
  g3: [T3 -> U3] = (LAMBDA (t: T3): t+1)
  e3: [U3 -> T3] = (LAMBDA (u: U3): u-1)
  ref3: predicate[[T3, U3]] = (LAMBDA (p: [T3, U3]): p`1 + 1 = p`2)

  IMPORTING refinement[T3, U3, equivT, equivU, g3, e3, ref3]
END infinite_nats_finite_equivalence_classes

% Refinement between infinite sets of nats with a finite number of
% equivalence classes in one type and an infinite number of trivial
% equivalance classes in the other.
infinite_to_infinite_trivial: THEORY % I x I (finite equiv. x infinite equiv.)
BEGIN
  IMPORTING ints@div
  T4: TYPE = nat
  U4: TYPE = nat
  IMPORTING relations[T4], relations[U4],
            QuotientDefinition[T4], QuotientDefinition[U4];

  equivT(t0, t1: T4): bool = div(t0,10) = div(t1,10)
  equivU(u0, u1: U4): bool = u0 = u1
  g4: [T4 -> U4] = (LAMBDA (t: T4): div(t,10))
  e4: [U4 -> T4] = (LAMBDA (u: U4): 10*u)
  ref4: predicate[[T4, U4]] = (LAMBDA (p: [T4, U4]): div(p`1,10) = p`2)

  IMPORTING refinement[T4, U4, equivT, equivU , g4, e4, ref4]
END infinite_to_infinite_trivial

% @TODO Dragan - Write up summary of this theory as above.
% Added by Dragan SEP 10 
finite_to_infinite: THEORY % F x I (finite equiv. x finite equiv.)
BEGIN
  T6: TYPE = bool
  U6: TYPE = nat
  IMPORTING relations[T6], relations[U6]

  equivT(t0, t1: T6): bool = t0 = t1
  equivU(u0, u1: U6): bool = even?(u0) = even?(u1)
  g6: [T6 -> U6] = (LAMBDA (t: T6): IF t THEN 0 ELSE 1 ENDIF)
  e6: [U6 -> T6] = (LAMBDA (u: U6): even?(u))
  ref6: predicate[[T6, U6]] = (LAMBDA (p: [T6, U6]): p`1 = even?(p`2))

  IMPORTING refinement[T6, U6, equivT, equivU , g6, e6, ref6]
END finite_to_infinite

% @TODO Dragan - Write up summary of this theory as above.
infinite_to_finite_finite_equival_finite_equival_classes: THEORY % I x F (finite equiv. x finite equiv.)
BEGIN
  T7: TYPE = nat
  U7: TYPE = {0,1}
  IMPORTING relations[T7], relations[U7],
            QuotientDefinition[T7], QuotientDefinition[U7];
 
  equivT(t0, t1: T7): bool = even?(t0) = even?(t1)
  equivU(u0, u1: U7): bool = u0 = u1   
  g7: [T7 -> U7] = (LAMBDA (t: T7):  IF (even?(t)) THEN 0 ELSE 1 ENDIF)
  e7: [U7 -> T7] = (LAMBDA (u: U7): IF (u = 0) THEN 0 ELSE 1 ENDIF)
  ref7: predicate[[T7, U7]] = (LAMBDA (p: [T7, U7]):
                               IF (even?(p`1)) THEN p`2 = 0 ELSE p`2 = 1 ENDIF)
  IMPORTING refinement[T7, U7, equivT, equivU , g7, e7, ref7]
END infinite_to_finite_finite_equival_finite_equival_classes

% @TODO Missing I x F (infinite equiv. x finite equiv.)

infinite_to_finite_infinite_equival_finite_equival_classes: THEORY % I x F (infinite equiv. x finite equiv.)
BEGIN
  T7: TYPE = nat
  U7: TYPE = below(2)
  IMPORTING relations[T7], relations[U7],
            QuotientDefinition[T7], QuotientDefinition[U7];
 
  equivT(t0, t1: T7): bool = odd?(t0+1) = even?(t1) OR even?(t0) = even?(t1)  % check with Joe !
  equivU(u0, u1: U7): bool = odd?(u0+1) = even?(u1)  
  g7: [T7 -> U7] = (LAMBDA (t: T7): IF (even?(t)) THEN 0 ELSE 1 ENDIF  )
  e7: [U7 -> T7] = (LAMBDA (u: U7): IF ( even?(u)) THEN 0 ELSE 1 ENDIF)
  ref7: predicate[[T7, U7]] = (LAMBDA (p: [T7, U7]):
                               IF ( even?(p`1)) THEN p`2 = 0 ELSE p`2 = 1 ENDIF)
 IMPORTING refinement[T7, U7, equivT, equivU , g7, e7, ref7]
END infinite_to_finite_infinite_equival_finite_equival_classes

% @TODO Missing F x I (finite equiv. x infinite equiv.)
finite_to_infinite_finite_equival_infinite_equival_classes: THEORY % F x I (finite equiv. x infinite equiv.)
BEGIN
  T8: TYPE = below(2)
  U8: TYPE = nat
  IMPORTING relations[T8], relations[U8],
            QuotientDefinition[T8], QuotientDefinition[U8];
 
  equivT(t0, t1: T8): bool = odd?(t0+1) = even?(t1) % check with Joe !
  equivU(u0, u1: U8): bool = odd?(u0+1) = even?(u1) OR even?(u0) = even?(u1)  
  g8: [T8 -> U8] = (LAMBDA (t: T8): IF (even?(t)) THEN 0 ELSE 1 ENDIF  )
  e8: [U8 -> T8] = (LAMBDA (u: U8): IF ( even?(u)) THEN 0 ELSE 1 ENDIF)
  ref8: predicate[[T8, U8]] = (LAMBDA (p: [T8, U8]):
                               IF ( even?(p`2)) THEN p`1 = 0 ELSE p`1 = 1 ENDIF)
 IMPORTING refinement[T8, U8, equivT, equivU , g8, e8, ref8]
END finite_to_infinite_finite_equival_infinite_equival_classes

% The collection of all simple examples.
simplest_examples: THEORY
BEGIN
  IMPORTING singleton_example, finite_nats_trivial,
            finite_nats_non_trivial, 
             infinite_to_infinite_trivial, finite_to_infinite,
            infinite_nats_finite_equivalence_classes,
            infinite_to_finite_finite_equival_finite_equival_classes,
            infinite_to_infinite_infinite_equival_finite_equival_classes,
            infinite_to_finite_infinite_equival_finite_equival_classes,
            finite_to_infinite_finite_equival_infinite_equival_classes
               

END simplest_examples
